### 1.进程与线程

#### 1.1 进程

- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在

        指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的

- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。

- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器

       等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

#### 1.2 线程

- 一个进程之内可以分为一到多个线程。

- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行

- Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作

  为线程的容器

#### 1.3进程线程对比

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集

- 进程拥有共享的资源，如内存空间等，供其内部的线程共享

- 进程间通信较为复杂
  -   同一台计算机的进程通信称为 IPC（Inter-process communication）
  -   不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP	

- 线通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低



### 2.并行与并发

单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows

下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感

觉是 同时运行的 。总结为一句话就是： **微观串行，宏观并行** 。

一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent

#### 2.1并行

并行（parallel）是同一时间动手做（doing）多件事情的能力

#### 2.2并发

并发（concurrent）是同一时间应对（dealing with）多件事情的能力



### 3.线程的创建和使用

创建线程的四种方式   

#### 3.1方式一：继承Thread类

```java
/**
 *多线程的创建： 方式一； 继承于Thread类
 * 1.创建一个类继承Thread类的子类
 * 2.重写Thread类的Run()方法 ->将次线程执行的操作声明在run()中
 * 3.创建Thread类的子类的对象
 * 4.通过此对象调用start()
 *
 * 例子： 遍历100以内的所有偶数
 *
 * @author 梦白
 * @create 2020-02-15 16:16
 * @destination 多线程的使用方式
 */

//1.创建一个类继承Thread类的子类
class myThread extends Thread{

    //2.重写Thread类的Run()方法
    @Override
    public void run() {
        for (int i = 0;i < 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + i);


            }

        }
    }
}

public class ThreadTest {
    public static void main(String[] argS) {
//        3.创建Thread类的子类的对象
        myThread t1 = new myThread();
//        4.通过此对象调用start() :①启动当前线程 ②调用当前线程的run()
        t1.start();
//        问题一:我们不能直接调用run()的方式启动线程
//        t1.run();

//        问题二:再启动线程遍历100以内的偶数，不可以还让已经start()的线程去执行会报错：java.lang.IllegalThreadStateException
//        t1.start();
//        我们需要创建一个新的线程对象
        myThread t2 = new myThread();
        t2.start();

        for (int i = 0;i < 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + i );
            }
        }

    }
}
```



#### 3.2方式二：实现Runnable

```java
package atguigu.java;

/**
 *创建多线程的方式二：实现Runnable接口
 *  1.创建一个实现了Runnable接口的类
 *  2.实现类去实现Runnable中的抽象方法：run()
 *  3.创建实现类的对象
 *  4.将次对象作为参数传递到Thread类的构造器中，创建Thread类的对象
 *  5.通过Thread类的对象调用start();
 *
 *
 * 比较创建线程的两种方式；
 * 开发中：有限选择实现Runnable接口方式
 * 原因:1.实现的方式没有类的单继承局限性
 *      2.实现的方式更适合来处理多个线程有共享数据的情况
 *
 *  相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在un()中
 * @author 梦白
 * @create 2020-02-16 18:37
 * @destination
 */

//1.创建一个实现了Runnable接口的类
class mThread implements Runnable{

//    2.实现类去实现Runnable中的抽象方法：run()
    @Override
    public void run() {
        for(int i = 0;i < 100;i++){
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}

public class ThreadTest1 {
    public static void main(String[] args) {
//        3.创建实现类的对象
        mThread mThread = new mThread();
//        4.将次对象作为参数传递到Thread类的构造器中，创建Thread类的对象
        Thread t = new Thread(mThread);
//        5.通过Thread类的对象调用start();
        t.start();
    }
}

```

#### 3.3方式三：实现Calable

```java
package atguigu.java2;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增
 *
 *
 * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
 * 1. call()可以有返回值的。
 * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
 * 3. Callable是支持泛型的
 *
 * @author shkstart
 * @create 2019-02-15 下午 6:01
 */
//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}


public class ThreadNew {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();

        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}

```


#### 3.4方式四：线程池

```java
package atguigu.java2;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

/**
 *
 * 创建线程的方式四：使用线程池
 *
 * 好处：
 * 1.提高响应速度（减少了创建新线程的时间）
 * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
 * 3.便于线程管理
 *      corePoolSize：核心池的大小
 *      maximumPoolSize：最大线程数
 *      keepAliveTime：线程没有任务时最多保持多长时间后会终止
 * @author 梦白
 * @create 2020-02-20 15:06
 * @destination
 */

class NumberThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0;i < 100;i++){
            if(i % 2 ==0){
                System.out.println(i);

            }
        }

    }
}


public class ThreadPool {
    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        //多态：向下转型
        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor)service;

//        System.out.println(service.getClass());
        //设置线程池的属性
//        threadPoolExecutor.setCorePoolSize();//核心池的大小
//        threadPoolExecutor.setMaximumPoolSize();//最大线程数
//        threadPoolExecutor.setKeepAliveTime();//线程没有任务时最多保持多长时间后会终止

        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());
//        service.submit(Callable callable);
        service.shutdown();



    }
}

```

###  4.常用的方法：

```
package atguigu.java;

/**
 * 测试Thread中的常用方法：
 * 1. start() 启动当前线程； 调用当前线程的run();
 * 2. run() 通常需要重写Thread类中的此方法,将创建的线程要执行的操作声明在此方法中
 * 3. currentThread() 静态方法；返回当前代码的线程
 * 4. getName() :获取当前线程的名字
 * 5. setName() :设置当前线程的名字
 * 6. yield() ：释放当前cpu的执行权
 * 7.join（）：在现场a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b完全执行完以后，线程a才借宿阻塞状态
 * 8.stop() 已过时，当执行此方法时，强制结束当前线程
 * 9.sleep(Long millitime): 让当前线程 “睡眠” 指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态
 * 10. isAlive() 判断当前线程是否存活
 *
 *
 * 线程的优先级；
 * 1、
 * max_priority:10
 * min_priority:1
 * morm_priority:5   --->默认优先级
 * 2、如何获取和设置当前线程的优先级：
 * getPriority():获取线程的优先级
 * setPriority(int p)：设置线程的优先级
 *
 * 说明：高优先级的线程要抢占低优先级线程cpu执行权。但是只是从概率上讲，高优先级的线程高频率下被执行
 *         并不意味着只有当高优先级的线程执行完以后，低优先级线程才执行
 *
 * @author 梦白
 * @create 2020-02-15 17:59
 * @destination 测试Thread中的常用方法
 */


class HelloThread extends Thread {
    private String name;

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {

             /*   try {
                    sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }*/
                System.out.println(Thread.currentThread().getName() + getPriority() + ":" + i);
            }
//            if (i % 20 ==0) {
//                this.yield();  //this标识当前类的对象  或者  Thread.currentThread().yiel
//
//            }

        }

    }

    public HelloThread(String name) {
        super(name);
    }
}


public class ThreadMethodTest {
    public static void main(String[] args) {
        HelloThread h = new HelloThread("构造方法设置线程名");
//        设置线程名称方法 二
//        h.setName("线程一");
        h.setPriority(Thread.MAX_PRIORITY);
        h.start();
//        设置线程名称方法 二

        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        Thread.currentThread().setName("主线程");
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+ Thread.currentThread().getPriority() + ":" + i);
            }
            /*if (i == 20) {
                try {
                    h.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }*/
        }

//            System.out.println(h.isAlive());
    }
}



```

#### 4.1主线程和守护线程

默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守

护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。

列：

```java
log.debug("开始运行...");
Thread t1 = new Thread(() -> {
 log.debug("开始运行...");
 sleep(2);
 log.debug("运行结束...");
}, "daemon");
// 设置该线程为守护线程
t1.setDaemon(true);
t1.start();
sleep(1);
log.debug("运行结束...");
```

输出：

```java
08:26:38.123 [main] c.TestDaemon - 开始运行... 
08:26:38.213 [daemon] c.TestDaemon - 开始运行... 
08:26:39.215 [main] c.TestDaemon - 运行结束...
```

> **注意**
>
> 垃圾回收器线程就是一种守护线程
>
> Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等
>
> 待它们处理完当前请求



#### 4.2线程的通信

```java
package atguigu.java2;

/**
 * * 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印
 *  *
 *  * 涉及到的三个方法：
 *  * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
 *  * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
 *  * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。
 *  *
 *  * 说明：
 *  * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。
 *  * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。
 *  *    否则，会出现IllegalMonitorStateException异常
 *  * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。
 *  *
 *  * 面试题：sleep() 和 wait()的异同？
 *  * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
 *  * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
 *  *          2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
 *  *          3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。
 *
 * @author 梦白
 * @create 2020-02-18 11:51
 * @destination
 */
class Number implements Runnable{
    private int number = 1;

    @Override
    public void run(){
        while (true){

            synchronized (this){
//                一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
                this.notify();

                if (number <= 100){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + number);
                    number ++;
                    try {
                        //调用此方法线程进入阻塞状态，并释放同步监视器。
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }else{
                    break;
                }

            }


        }


    }
}

public class CommunicationTest {
    public static void main(String[] args) {
        Number n = new Number();
        Thread t1 = new Thread(n);
        Thread t2 = new Thread(n);
        t1.setName("一号");
        t2.setName("二号");
        t1.start();
        t2.start();
    }
}

```

### 

### 5 Thread Status

#### 5.1操作系统层面

- 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联

- 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行

- 【运行状态】指获取了 CPU 时间片运行中的状态当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换

- 【阻塞状态】如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们

- 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态



#### 5.2 JavaAPI层面

- NEW 线程刚被创建，但是还没有调用 start() 方法

- RUNNABLE 当调用了 start() 方法之后，注意，**Java API** 层面的 RUNNABLE 状态涵盖了 **操作系统** 层面的

- 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为

     是可运行）

- BLOCKED ， WAITING ， TIMED_WAITING 都是 **Java API** 层面对【阻塞状态】的细分，后面会在状态转换一节

      详述

- TERMINATED 当线程代码运行结束

### 6 线程的安全问题

#### 6.1共享问题

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？

例：

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName Test15
 * @Author ZCC
 * @Date 2022/04/08
 * @Description TODO
 * @Version 1.0
 */
@Slf4j(topic = "c.Test15")
public class Test15 {
    static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter--;
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("{}", counter);
    }

}

```

结果1：负数

```java
15:08:02.501 c.Test15 [main] - -298
```

结果2：正确结果

```java
15:09:40.153 c.Test15 [main] - 0
```

结果3：正数

```java
15:11:29.677 c.Test15 [main] - 1738
```

**问题分析：**

以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是**原子操作**。

上诉代码如果在单线程下执行是没有问题的，多线程**读**的情况下也没有问题。

有问题的是**多线程**的情况下对**共享数据**的<span style="color:red">交替读写</span>。

在Java内存模型中 每个线程对共享变量操作都不是直接操作的主内存中的数据，会把主内存中的copy一份副本到自己的工作内存中操作，完成之后再回写到主内存中，线程的处理速度不确定有快慢无法人为控制 所有会存在上诉线程不安全问题。



**临界区  Critical Section**

- 一个程序运行多个线程本身是没有问题的

- 问题出在多个线程访问**共享资源**

  - 多个线程读**共享资源**其实也没有问题

  - 在多个线程对**共享资源**读写操作时发生指令交错，就会出现问题

- 一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区**

例：

```java
static int counter = 0;
static void increment() 
// 临界区
{ 
 counter++; 
}
static void decrement() 
// 临界区
{ 
 counter--; 
}
```

**竞态条件** **Race Condition**

多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**

#### 6.2 synchronized 解决方案

***** **应用之互斥**

为了避免临界区的竞态条件发生，有多种手段可以达到目的。

- 阻塞式的解决方案：synchronized，Lock

- 非阻塞式的解决方案：原子变量

本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。



> **注意**
>
> 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：
>
> - 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
>
> - 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点



**语法：**

```java
synchronized(对象) // 线程1， 线程2(blocked)
{
 临界区
}
```

**解决：**

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName Test15
 * @Author ZCC
 * @Date 2022/04/08
 * @Description TODO
 * @Version 1.0
 */
@Slf4j(topic = "c.Test15")
public class Test15 {
    static int counter = 0;
    static final Object lock = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (lock){
                    counter++;
                }

            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (lock){
                    counter--;
                }
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("{}", counter);
    }

}

```

**结果：** 不管执行多少次都是0

```java
15:47:39.568 c.Test15 [main] - 0
```



---



#### 6.6老笔记

##### 线程的同步（解决线程的安全问题）三种方式

###### 方式一：同步代码块

```java
package atguigu.java;

/**
 * 例子：创建三个窗口卖票，总票数为100张，使用实现Runnable接口方式
 *
 * 1.问题：卖票过程中，出现了重票，错票 --->出现了线程的安全问题
 * 2.问题出现的原因； 当某个线程操作车票的过程中，尚未操作完成时，其它线程参与进来，也操作车票
 * 3.如何解决：当一个线程a在操作ticket的时候，其它线程不能参与进来，直到线程a操作完成ticket时
 *              其他线程才可以操作ticket，这种情况及时线程a出现了阻塞，也不能被改变
 *4.在java中，我们通过同步机制，来解决线程安全问题
 * 方式一：同步代码块
 *          synchronized(同步监视器）{
 *              //需要被同步的代码
 *          }
 *说明: 1.操作共享数据的代码，即为需要被同步的代码
 *      2.共享数据，多个线程共同操作的变量，比如：ticket就是共享数据
 *      3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁
 *          要求：多个线程必须要共用一把锁。
 *
 * 方式二：同步方法；
 *
 *
 *
 * 5.同步的方式，解决了线程的安全问题   ----好处
 *  操作同步代码时。只能有一个线程参与，其它线程等待，相当于一个单线程的过程，效率低  ---局限性
 * @author 梦白
 * @create 2020-02-17 18:34
 * @destination
 */

class Windows1 implements   Runnable{
    private int ticket = 100;
    private static Object obj = new Object();
    @Override
    public void run() {
        while (true){

            synchronized (this){   //此时的this:唯一的Window1类的对象   //方式二：synchronized (obj) {


        if(ticket > 0){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "卖票，票号为：" + ticket);
                ticket--;
            }else{
            break;
        }
            }
        }

    }
}

public class WindowTest01  {
    public static void main(String[] args) {
        Windows1 w = new Windows1();
        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();
    }



}


```

方式二：同步方法

```java
package atguigu.java;

/**
 *
 *  * 使用同步方法解决实现Runnable接口的线程安全问题
 *  *
 *  *
 *  *  关于同步方法的总结：
 *  *  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
 *  *  2. 非静态的同步方法，同步监视器是：this
 *  *     静态的同步方法，同步监视器是：当前类本身
 *
 * @author 梦白
 * @create 2020-02-18 8:07
 * @destination 使用同步方法解决试下Runnable接口的线程安全
 */
class Windows3 implements Runnable{
    private int  ticket = 100;

    @Override
    public void run() {
        while(true){
            show();
        }

    }

    private synchronized void show(){  //同步监视器：this
        if(ticket > 0){
            System.out.println(Thread.currentThread().getName() + "卖票，票号为："+ticket);
            ticket --;
        }

    }
}

public class WindowsTest03   {
    public static void main(String[] args){
        Windows3 w = new Windows3();
        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);
        t1.setName("窗口一号");
        t2.setName("窗口二号");
        t3.setName("窗口三号");
        t1.start();
        t2.start();
        t3.start();

    }
}

```

##### 方法三：Lock锁  ---jdk5.0新增

```java
package atguigu.java;

import java.util.concurrent.locks.ReentrantLock;

/**
 * 解决线程的安全问题方式三：Lock锁  ---jdk5.0新增
 *
 * 1.面试题：synchronized 与 LOck的异同
 *      相同：二者都可以解决线程安全
 *         不同：synchronized机制在执行相应的同步代码以后，自动释放同步监视器
 *              Lock需要手动的启动（Lock()），同时结束也需要手动的实现（unlock()）
 *2，使用先后顺序：
 * lock -> 同步代码块（已经进入了方法体，分配了相应资源） ->同步方法（在方法体外）
 * @author 梦白
 * @create 2020-02-18 10:48
 * @destination
 */

class Windows05 implements Runnable{
    private int ticket = 100;
    //1.实例化ReentrantLock
    private ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true){

            try {
                //2.调用锁方法lock()
                lock.lock();
                if(ticket >0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "卖票，票号：" + ticket);
                    ticket--;
                }
            } finally {
                //3.调用解锁
                lock.unlock();
            }

        }

    }
}

public class LockTest {
    public static void main(String[] args) {
        Windows05 w = new Windows05();
        Thread t = new Thread(w);
        t.start();
    }
}

```



### 7 变量的线程安全分析

#### 7.1**成员变量和静态变量是否线程安全？**

- 如果它们没有共享，则线程安全

- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况

  - 如果只有读操作，则线程安全

  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全

#### 



#### 7.2**局部变量是否线程安全？**

- 局部变量是线程安全的

- 但局部变量引用的对象则未必

  - 如果该对象没有逃离方法的作用访问，它是线程安全的

  - 如果该对象逃离方法的作用范围，需要考虑线程安全

#### 7.3代码分析

##### 7.3.1**局部变量线程安全分析**

每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享

```java
public static void test1() {

 int i = 10;

 i++; 

}
```

##### 7.3.2成员变量线程安全分析

代码：

```java
class ThreadUnsafe {
 ArrayList<String> list = new ArrayList<>();
 public void method1(int loopNumber) {
 for (int i = 0; i < loopNumber; i++) {
 // { 临界区, 会产生竞态条件
 method2();
 method3();
     // } 临界区
 }
 }
 private void method2() {
 list.add("1");
 }
 private void method3() {
 list.remove(0);
 }
}
```

执行：

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
 ThreadUnsafe test = new ThreadUnsafe();
 for (int i = 0; i < THREAD_NUMBER; i++) {
 new Thread(() -> {
 test.method1(LOOP_NUMBER);
 }, "Thread" + i).start();
 }
}
```

结果：

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错

```java
Exception in thread "Thread1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 
 at java.util.ArrayList.rangeCheck(ArrayList.java:657) 
 at java.util.ArrayList.remove(ArrayList.java:496) 
 at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35) 
 at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26) 
 at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14) 
 at java.lang.Thread.run(Thread.java:748)
```

分析：

- 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量

- method3 与 method2 分析相同



优化：

将全局变量list 改为局部变量

代码：

```java
class ThreadUnsafe {
 //ArrayList<String> list = new ArrayList<>();
 public void method1(int loopNumber) {
     
 ArrayList<String> list = new ArrayList<>();
     
 for (int i = 0; i < loopNumber; i++) {
 // { 临界区, 会产生竞态条件
 method2(list);
 method3(list);
     // } 临界区
 }
 }
 private void method2(ArrayList<String> list) {
 list.add("1");
 }
 private void method3(ArrayList<String> list) {
 list.remove(0);
 }
}
```

分析：

改为局部变量之后就不存在之前的问题。

- list 是局部变量，每个线程调用时会创建其不同实例，没有共享

- 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象

- method3 的参数分析与 method2 相同



方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会带来线程安全问题？

- 情况1：有其它线程调用 method2 和 method3

  - 没有线程安全问题，别的线程直接调用method2或者method3 传的值List 是当前线程的无法和别的线程共享

- 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即

  - 有线程安全问题 子类覆盖父类的方法 在方法里重新创建线程 此时传入的list 是新建线程的共享变量

   代码：

  ```java
  //public  void method1(int loopNumber) { 
  public final void method1(int loopNumber) {
   ArrayList<String> list = new ArrayList<>();
   for (int i = 0; i < loopNumber; i++) {
   method2(list);
   method3(list);
   }
   }
   private void method2(ArrayList<String> list) {
   list.add("1");
        }
   private void method3(ArrayList<String> list) {
   list.remove(0);
   }
  }
  class ThreadSafeSubClass extends ThreadSafe{
   @Override
   public void method3(ArrayList<String> list) {
   new Thread(() -> {
   list.remove(0);
   }).start();
   }
  }
  ```

  > 从这个例子可以看出 private 或 final提供【安全】的意义所在，请体会开闭原则中的【闭】



### 8 Monitor

Monitor 被翻译为**监视器**或**管程**

每个Java对象都可以关联一个Monitor 对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。

![img](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309172316-799735.png)

- 刚开始时Monitor中的Owner为null
- 当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner
- 当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList中变成BLOCKED状态
- Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的
- 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析

> 注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则



#### synchronized原理

代码如下 Test17.java

```java
    static final Object lock=new Object();
    static int counter = 0;
    public static void main(String[] args) {
        synchronized (lock) {
            counter++;
        }
    }
```

反编译后的部分字节码

```java
 0 getstatic #2 <com/concurrent/test/Test17.lock>
 # 取得lock的引用（synchronized开始了）
 3 dup    
 # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用
 4 astore_1
 # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中
 5 monitorenter
 # 将lock对象的Mark Word置为指向Monitor指针
 6 getstatic #3 <com/concurrent/test/Test17.counter>
 9 iconst_1
10 iadd
11 putstatic #3 <com/concurrent/test/Test17.counter>
14 aload_1
# 从局部变量表中取得lock的引用，放入操作数栈栈顶
15 monitorexit
# 将lock对象的Mark Word重置，唤醒EntryList
16 goto 24 (+8)
# 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁
19 astore_2
20 aload_1
21 monitorexit
22 aload_2
23 athrow
24 return
```

> 注意：方法级别的 synchronized 不会在字节码指令中有所体现



 synchronized 原理进阶

##### 轻量级锁

轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是`synchronized`，假设有两个方法同步块，利用同一个对象加锁

```
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

1. 每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference
   1. ![1583755737580](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309200902-382362.png)
2. 让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中
   1. ![1583755888236](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309201132-961387.png)
3. 如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态01，如下所示
   1. ![1583755964276](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309201247-989088.png)
4. 如果cas失败，有两种情况
   1. 如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段
   2. 如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数
      1. ![1583756190177](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309201634-451646.png)
5. 当线程退出synchronized代码块的时候，**如果获取的是取值为 null 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一
   1. ![1583756357835](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309201919-357425.png)
6. 当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象
   1. 成功则解锁成功
   2. 失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

##### 锁膨胀

如果在尝试加轻量级锁的过程中，cas操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。

1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁
   1. ![1583757433691](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309203715-909034.png)
2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程
   1. 即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态
   2. ![1583757586447](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309203947-654193.png)
3. 当Thread-0 推出synchronized同步块时，使用cas将Mark Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程

##### 自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁

1. 自旋重试成功的情况
   1. ![1583758113724](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309204835-425698.png)
2. 自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁
   1. ![1583758136650](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309204915-424942.png)

自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能

##### 偏向锁

在轻量级的锁中，我们可以发现，如果同一个线程对同一个2对象进行重入锁时，也需要执行CAS操作，这是有点耗时滴，那么java6开始引入了偏向锁的东东，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，**之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了**

![1583760728806](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309213209-28609.png)

##### 偏向状态

![1583762169169](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200309215610-51761.png)

一个对象的创建过程

1. 如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值.

2. 偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-`XX:BiasedLockingStartupDelay=0`来禁用延迟

3. 注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中

4. 实验Test18.java，加上虚拟机参数-XX:BiasedLockingStartupDelay=0进行测试

   1. ```
      public static void main(String[] args) throws InterruptedException {
              Test1 t = new Test1();
              test.parseObjectHeader(getObjectHeader(t))；
              synchronized (t){
                  test.parseObjectHeader(getObjectHeader(t));
              }
              test.parseObjectHeader(getObjectHeader(t));
          }
      ```

      1. 输出结果如下，三次输出的状态码都为101

      ```
      biasedLockFlag (1bit): 1
      	LockFlag (2bit): 01
      biasedLockFlag (1bit): 1
      	LockFlag (2bit): 01
      biasedLockFlag (1bit): 1
      	LockFlag (2bit): 01
      ```

测试禁用：如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode，age都为0，hashcode是第一次用到`hashcode`时才赋值的。在上面测试代码运行时在添加 VM 参数`-XX:-UseBiasedLocking`禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出`synchronized`状态变回001

1. 测试代码Test18.java 虚拟机参数`-XX:-UseBiasedLocking`

2. 输出结果如下，最开始状态为001，然后加轻量级锁变成00，最后恢复成001

   ```
   biasedLockFlag (1bit): 0
   	LockFlag (2bit): 01
   LockFlag (2bit): 00
   biasedLockFlag (1bit): 0
   	LockFlag (2bit): 01
   ```

##### 撤销偏向锁-hashcode方法

测试 `hashCode`：当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存`hashcode`的值了

1. 测试代码如下，使用虚拟机参数`-XX:BiasedLockingStartupDelay=0` ，确保我们的程序最开始使用了偏向锁！但是结果显示程序还是使用了轻量级锁。 Test20.java

   ```
       public static void main(String[] args) throws InterruptedException {
           Test1 t = new Test1();
           t.hashCode();
           test.parseObjectHeader(getObjectHeader(t));
   
           synchronized (t){
               test.parseObjectHeader(getObjectHeader(t));
           }
           test.parseObjectHeader(getObjectHeader(t));
       }
   ```

2. 输出结果

   ```
   biasedLockFlag (1bit): 0
   	LockFlag (2bit): 01
   LockFlag (2bit): 00
   biasedLockFlag (1bit): 0
   	LockFlag (2bit): 01
   ```

##### 撤销偏向锁-其它线程使用对象

这里我们演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，我们使用`wait` 和 `notify` 来辅助实现

1. 代码 Test19.java，虚拟机参数`-XX:BiasedLockingStartupDelay=0`确保我们的程序最开始使用了偏向锁！

2. 输出结果，最开始使用的是偏向锁，但是第二个线程尝试获取对象锁时，发现本来对象偏向的是线程一，那么偏向锁就会失效，加的就是轻量级锁

   ```
   biasedLockFlag (1bit): 1
   	LockFlag (2bit): 01
   biasedLockFlag (1bit): 1
   	LockFlag (2bit): 01
   biasedLockFlag (1bit): 1
   	LockFlag (2bit): 01
   biasedLockFlag (1bit): 1
   	LockFlag (2bit): 01
   LockFlag (2bit): 00
   biasedLockFlag (1bit): 0
   	LockFlag (2bit): 01
   ```

##### 撤销 - 调用 wait/notify

会使对象的锁变成重量级锁，因为wait/notify方法之后重量级锁才支持

##### 批量重偏向

如果对象被多个线程访问，但是没有竞争，这时候偏向了线程一的对象又有机会重新偏向线程二，即可以不用升级为轻量级锁，可这和我们之前做的实验矛盾了呀，其实要实现重新偏向是要有条件的：就是超过20对象对同一个线程如线程一撤销偏向时，那么第20个及以后的对象才可以将撤销对线程一的偏向这个动作变为将第20个及以后的对象偏向线程二。Test21.java

### 9线程的状态转换

#### 9.1 NEW-> RUNNABLE 

线程新建状态是NEW

调用start() 方法之后线程由NEW ->RUNNABLE

#### 9.2RUNNABLE <-->WAITING

- 线程用synchronized(obj)获取了对象锁后

  - 调用obj.wait()方法时，t 线程从RUNNABLE --> WAITING
  - 调用obj.notify()，obj.notifyAll()，t.interrupt()时

    - 竞争锁成功，t 线程从WAITING --> RUNNABLE
  - 竞争锁失败，t 线程从WAITING --> BLOCKED

  

  ```java
  当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --> WAITING
  调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING --> RUNNABLE
      
  当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING 注意是当前线程在t 线程对象的监视器上等待
  t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --> RUNNABLE   
  ```

  

  代码：

  ```java
  package cn.itcast.test;
  
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.context.annotation.Lazy;
  
  import java.util.concurrent.TimeUnit;
  
  /**
   * @ProjectName juc
   * @Package cn.itcast.test
   * @ClassName TestWaitNotify
   * @Author ZCC
   * @Date 2022/04/08
   * @Description TODO
   * @Version 1.0
   */
  @Slf4j(topic = "c.TestWaitNotify")
  public class TestWaitNotify {
      final static Object obj = new Object();
  
      public static void main(String[] args) throws InterruptedException {
          Thread t1 = new Thread(() -> {
              synchronized (obj) {
                  log.debug("执行....");
                  try {
                      log.debug(Thread.currentThread().getName() + "：" + Thread.currentThread().getState());
                      obj.wait();
                      log.debug(Thread.currentThread().getName() + "：" + Thread.currentThread().getState());
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  log.debug("其它代码...."); // 断点
              }
              log.debug(Thread.currentThread().getName() + "：" + Thread.currentThread().getState());
          }, "t1");
  
  
          Thread t2 = new Thread(() -> {
              synchronized (obj) {
                  log.debug("执行....");
                  try {
                      log.debug(Thread.currentThread().getName() + "：" + Thread.currentThread().getState());
                      obj.wait();
                      log.debug(Thread.currentThread().getName() + "：" + Thread.currentThread().getState());
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  log.debug("其它代码...."); // 断点
              }
              log.debug(Thread.currentThread().getName() + "：" + Thread.currentThread().getState());
          }, "t2");
  
          log.debug(t1.getName() + "：" + t1.getState());
          log.debug(t2.getName() + "：" + t2.getState());
          t1.start();
          log.debug(t1.getName() + "：" + t1.getState());
          t2.start();
          log.debug(t2.getName() + "：" + t2.getState());
  
  
          TimeUnit.SECONDS.sleep(1);
          log.debug("唤醒 obj 上其它线程");
          synchronized (obj) {
              obj.notifyAll(); // 唤醒obj上所有等待线程 断点
          }
      }
  }
  
  
  ```

  

  

#### 9.3 RUNNABLE <--> TIMED_WAITING

- t 线程用 synchronized(obj) 获取了对象锁后

- 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --> TIMED_WAITING

- t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时

  - 竞争锁成功，t 线程从 TIMED_WAITING --> RUNNABLE

  - 竞争锁失败，t 线程从 TIMED_WAITING --> BLOCKED

```java
当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --> TIMED_WAITING 注意是当前线程在t 线程对象的监视器上等待
当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING --> RUNNABLE
    
当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
当前线程等待时间超过了 n 毫秒或调用了线程 的 interrupt() ，当前线程从 TIMED_WAITING --> RUNNABLE
    
当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE --> TIMED_WAITING
调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING--> RUNNABLE
```

#### 9.4 RUNNABLE <----> TERMINATED

当前线程所有代码运行完毕，进入 TERMINATED



### 10 多把锁

将锁的粒度细分

- 好处，是可以增强并发度

- 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁



### 11 活跃性

#### 11.1死锁



##### 11.1.1 代码举例：

```java
package atguigu.java;

import static java.lang.Thread.sleep;

/**
 * 演示线程的死锁问题
 *
 * 1.死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，
 * 都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
 *
 * 2.说明：
 * 1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
 * 2）我们使用同步时，要避免出现死锁。
 * @author 梦白
 * @create 2020-02-18 9:27
 * @destination
 */
public class ThreadDemo {
    public static void main(String[] args) {

        StringBuffer s1 = new StringBuffer();
        StringBuffer s2 = new StringBuffer();


        new Thread(){
            @Override
            public void run() {

                synchronized (s1){

                    s1.append("a");
                    s2.append("1");

                    try {
                        sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }


                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");

                        System.out.println(s1);
                        System.out.println(s2);
                    }


                }

            }
        }.start();


        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s2){

                    s1.append("c");
                    s2.append("3");

                    try {
                        sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");

                        System.out.println(s1);
                        System.out.println(s2);
                    }

                }

            }
        }).start();


    }


}

```

##### 11.1.2 定位死锁

- jps

  - 使用 jps 定位进程 id

  - 再用 jstack 定位死锁

    ```shell
    cmd > jps
    Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
    12320 Jps
    22816 KotlinCompileDaemon
    33200 TestDeadLock // JVM 进程
    11508 Main
    28468 Launcher
    ```

    ```shell
    cmd > jstack 33200
    Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
    2018-12-29 05:51:40
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):
    "DestroyJavaVM" #13 prio=5 os_prio=0 tid=0x0000000003525000 nid=0x2f60 waiting on condition 
    [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
    "Thread-1" #12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry 
    [0x000000001f54f000]
     java.lang.Thread.State: BLOCKED (on object monitor)
     at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)
     - waiting to lock <0x000000076b5bf1c0> (a java.lang.Object)
     - locked <0x000000076b5bf1d0> (a java.lang.Object)
     at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source)
     at java.lang.Thread.run(Thread.java:745)
    "Thread-0" #11 prio=5 os_prio=0 tid=0x000000001eb68800 nid=0x1b28 waiting for monitor entry 
    [0x000000001f44f000]
     java.lang.Thread.State: BLOCKED (on object monitor)
     at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)
     - waiting to lock <0x000000076b5bf1d0> (a java.lang.Object)
    北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090
    避免死锁要注意加锁顺序
    另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到
    CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查
    哲学家就餐问题
     - locked <0x000000076b5bf1c0> (a java.lang.Object)
     at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source)
     at java.lang.Thread.run(Thread.java:745)
     
    // 略去部分输出
    Found one Java-level deadlock:
    =============================
    "Thread-1":
     waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),
     which is held by "Thread-0"
    "Thread-0":
     waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),
     which is held by "Thread-1"
    Java stack information for the threads listed above:
    ===================================================
    "Thread-1":
     at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)
     - waiting to lock <0x000000076b5bf1c0> (a java.lang.Object)
     - locked <0x000000076b5bf1d0> (a java.lang.Object)
     at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source)
     at java.lang.Thread.run(Thread.java:745)
    "Thread-0":
     at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)
     - waiting to lock <0x000000076b5bf1d0> (a java.lang.Object)
     - locked <0x000000076b5bf1c0> (a java.lang.Object)
     at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source)
     at java.lang.Thread.run(Thread.java:745)
    Found 1 deadlock.
    ```

- jconsole

  - 打开jconsole idea控制台或者 cmd都行

  - 打开图形界面 进入 点击线程 下发点击检测死锁

    ```shel
    jconsole
    ```



**注意：**

- 避免死锁要注意加锁顺序

- 另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查





### 12.ReentrantLock

#### 12.1 语法

```java 
ReentrantLock lock = new ReentrantLock();


        try {
            lock.lock();
            log.info("into main");
            m1();
        } finally {
            //一定要放在finally里面
            lock.unlock();

        }
```



#### 12.2与synchronized异同？

区别:

- 可中断
- 可设置超时间
- 可以设置为公平锁
- 支持多个条件变量

相同：

都可支持可重入



#### 12.3可重入

什么是可重入？

可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，索引拥有权力再次获得这把锁。

如果是不可重入锁，第二次获取时，自己会被锁挡住



可重入锁代码

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName ReentranLockTest1
 * @Author ZCC
 * @Date 2022/05/30
 * @Description TODO
 * @Version 1.0
 */
@Slf4j(topic = "c.ReentranLockTest1")
public class ReentranLockTest1 {
    public static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {

        try {
            lock.lock();
            log.info("into main");
            m1();
        } finally {
            lock.unlock();

        }

    }

    public static void m1() {

        try {
            lock.lock();
            log.info("into m1");
            m2();
        } finally {
            lock.unlock();


        }
    }

    public static void m2() {

        try {
            lock.lock();
            log.info("into m2");

        } finally {
            lock.unlock();


        }
    }
}


结果__________________
21:34:46.489 c.ReentranLockTest1 [main] - into main
21:34:46.490 c.ReentranLockTest1 [main] - into m1
21:34:46.490 c.ReentranLockTest1 [main] - into m2
```

#### 12.4 可打断

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName ReentranLockTest1
 * @Author ZCC
 * @Date 2022/05/30
 * @Description 可打断锁
 * @Version 1.0
 */
@Slf4j(topic = "c.ReentranLockTest2")
public class ReentranLockTest2 {
    public static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(() -> {
            //可打断锁
            //如果没有竞争那么次方法获取lock对象锁
            //如果有竞争就进入阻塞队列，可以被其它方法用interrupt方法打断
            log.debug("获取锁");
            try {
                lock.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
                log.debug("打断锁");
                //打断之后不往下执行
                return;
            }

            try {
                log.info("获取到锁");

            } finally {
                lock.unlock();
            }

        }, "t1");

        lock.lock();
        thread.start();

        Thread.sleep(1000);
        //打断
        thread.interrupt();


    }
}
```

#### 12.5锁超时

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName ReentranLockTest1
 * @Author ZCC
 * @Date 2022/05/30
 * @Description 可打断锁
 * @Version 1.0
 */
@Slf4j(topic = "c.ReentranLockTest3")
public class ReentranLockTest3 {
    public static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(() -> {


            try {
                log.info("尝试获取锁！");
                // if (!lock.tryLock()) {

                try {
                    if (!lock.tryLock(2, TimeUnit.SECONDS)) {

                        return;
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    //打断锁
                    return;
                }
                log.info("获取到锁！");

            } finally {

                lock.unlock();
            }


        }, "t1");


        lock.lock();
        thread.start();
        Thread.sleep(1000);
        lock.unlock();
    }
}
```

#### 12.6 公平锁

ReentrantLock 默认是非公平锁

synchronized 也是非公平锁

```java
//公平锁
ReentrantLock lock = new ReentrantLock(true);
//非公平锁
ReentrantLock lock = new ReentrantLock();
```

#### 12.7 条件变量

传统对象等待集合只有一个 waitSet， Lock可以通过newCondition()方法 生成多个等待集合Condition对象。 Lock和Condition 是一对多的关系

synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet等待
ReentrantLock的条件变量比 synchronized强大之处在于，它是支持多个条件变量的，这就好比
synchronized 是那些不满足条件的线程都在一间休息室等消息
而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来 唤醒

使用流程
1.await 前需要 获得锁
2.await 执行后，会释放锁，进入 conditionObject (条件变量)中等待
3.await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁
4.竞争 lock 锁成功后，从 await 后继续执行
5.signal 方法用来唤醒条件变量(等待室)汇总的某一个等待的线程
6.signalAll方法, 唤醒条件变量(休息室)中的所有线程

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName ReentranLockTest1
 * @Author ZCC
 * @Date 2022/05/30
 * @Description RenntrantLock 条件变量
 * @Version 1.0
 */
@Slf4j(topic = "c.ReentranLockTestReentranLockTest4")
public class ReentranLockTest4 {
    public static ReentrantLock lock = new ReentrantLock();
    static  Condition condition1 = lock.newCondition();
    static  Condition condition2 = lock.newCondition();

    public static void main(String[] args) throws InterruptedException {


        Thread t1 = new Thread(() -> {


            try {
                log.info("获取锁");
                lock.lock();

                log.info("等待");
                //等待
                condition1.await();

            } catch (Exception e) {
                log.info("error");
                e.printStackTrace();
            } finally {

                log.info("释放锁");
                lock.unlock();
            }
        }, "t1");


        t1.start();

        Thread.sleep(2000);
        lock.lock();
        //唤醒
        condition1.signal();
        lock.unlock();

    }
}
```



#### 12.8 Semaphore(信号量)

Semaphore（信号量）为多线程协作提供了更为强大的控制方法，前面的文章中我们学了synchronized和重入锁ReentrantLock，这2种锁一次都只能允许一个线程访问一个资源，而信号量可以控制有多少个线程可以**同时访问**特定的资源。

<font color="red">**Semaphore常用场景：限流**</font>

举个例子：

比如有个停车场，有5个空位，门口有个门卫，手中5把钥匙分别对应5个车位上面的锁，来一辆车，门卫会给司机一把钥匙，然后进去找到对应的车位停下来，出去的时候司机将钥匙归还给门卫。停车场生意比较好，同时来了100两车，门卫手中只有5把钥匙，同时只能放5辆车进入，其他车只能等待，等有人将钥匙归还给门卫之后，才能让其他车辆进入。

上面的例子中门卫就相当于Semaphore，车钥匙就相当于许可证，车就相当于线程。

##### Semaphore主要方法

- **Semaphore(int permits)**：构造方法，参数表示许可证数量，用来创建信号量
- **Semaphore(int permits,boolean fair)**：构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量
- **void acquire() throws InterruptedException**：从此信号量获取1个许可前线程将一直阻塞，相当于一辆车占了一个车位，此方法会响应线程中断，表示调用线程的interrupt方法，会使该方法抛出InterruptedException异常
- **void acquire(int permits) throws InterruptedException** ：和acquire()方法类似，参数表示需要获取许可的数量；比如一个大卡车要入停车场，由于车比较大，需要申请3个车位才可以停放
- **void acquireUninterruptibly(int permits)** ：和acquire(int permits) 方法类似，只是不会响应线程中断
- **boolean tryAcquire()**：尝试获取1个许可，不管是否能够获取成功，都立即返回，true表示获取成功，false表示获取失败
- **boolean tryAcquire(int permits)**：和tryAcquire()，表示尝试获取permits个许可
- **boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException**：尝试在指定的时间内获取1个许可，获取成功返回true，指定的时间过后还是无法获取许可，返回false
- **boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException**：和tryAcquire(long timeout, TimeUnit unit)类似，多了一个permits参数，表示尝试获取permits个许可
- **void release()**：释放一个许可，将其返回给信号量，相当于车从停车场出去时将钥匙归还给门卫
- **void release(int n)**：释放n个许可
- **int availablePermits()**：当前可用的许可数



##### Demo1：简单使用

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.Semaphore;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName SemaphoreTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description Semaphore信号量
 * @Version 1.0
 */
@Slf4j(topic = "c.SemaphoreTest1")
public class SemaphoreTest1 {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2);

        for (int i=0;i<10;i++){
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    log.info("当前线程；"+Thread.currentThread().getName()+",获取许可证");
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                    log.info("当前线程；"+Thread.currentThread().getName()+",释放许可证");
                }


            }).start();
        }


    }
}

```

输出：

```java
13:58:23.055 c.SemaphoreTest1 [Thread-1] - 当前线程；Thread-1,获取许可证
13:58:23.055 c.SemaphoreTest1 [Thread-0] - 当前线程；Thread-0,获取许可证
13:58:25.069 c.SemaphoreTest1 [Thread-0] - 当前线程；Thread-0,释放许可证
13:58:25.069 c.SemaphoreTest1 [Thread-2] - 当前线程；Thread-2,获取许可证
13:58:25.069 c.SemaphoreTest1 [Thread-1] - 当前线程；Thread-1,释放许可证
13:58:25.069 c.SemaphoreTest1 [Thread-3] - 当前线程；Thread-3,获取许可证
13:58:27.077 c.SemaphoreTest1 [Thread-3] - 当前线程；Thread-3,释放许可证
13:58:27.077 c.SemaphoreTest1 [Thread-2] - 当前线程；Thread-2,释放许可证
13:58:27.077 c.SemaphoreTest1 [Thread-5] - 当前线程；Thread-5,获取许可证
13:58:27.077 c.SemaphoreTest1 [Thread-4] - 当前线程；Thread-4,获取许可证
13:58:29.090 c.SemaphoreTest1 [Thread-4] - 当前线程；Thread-4,释放许可证
13:58:29.090 c.SemaphoreTest1 [Thread-7] - 当前线程；Thread-7,获取许可证
13:58:29.090 c.SemaphoreTest1 [Thread-6] - 当前线程；Thread-6,获取许可证
13:58:29.090 c.SemaphoreTest1 [Thread-5] - 当前线程；Thread-5,释放许可证
13:58:31.094 c.SemaphoreTest1 [Thread-6] - 当前线程；Thread-6,释放许可证
13:58:31.094 c.SemaphoreTest1 [Thread-9] - 当前线程；Thread-9,获取许可证
13:58:31.094 c.SemaphoreTest1 [Thread-7] - 当前线程；Thread-7,释放许可证
13:58:31.094 c.SemaphoreTest1 [Thread-8] - 当前线程；Thread-8,获取许可证
13:58:33.107 c.SemaphoreTest1 [Thread-9] - 当前线程；Thread-9,释放许可证
13:58:33.107 c.SemaphoreTest1 [Thread-8] - 当前线程；Thread-8,释放许可证
```

代码中`new Semaphore(2)`创建了许可数量为2的信号量，每个线程获取1个许可，同时允许两个线程获取许可，从输出中也可以看出，同时有两个线程可以获取许可，其他线程需要等待已获取许可的线程释放许可之后才能运行。为获取到许可的线程会阻塞在`acquire()`方法上，直到获取到许可才能继续。



##### Demo2：获取许可证之后不释放

```JAVA
package com.itsoku.chat12;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Demo2 {
    static Semaphore semaphore = new Semaphore(2);
    public static class T extends Thread {
        public T(String name) {
            super(name);
        }
        @Override
        public void run() {
            Thread thread = Thread.currentThread();
            try {
                semaphore.acquire();
                System.out.println(System.currentTimeMillis() + "," + thread.getName() + ",获取许可!");
                TimeUnit.SECONDS.sleep(3);
                System.out.println(System.currentTimeMillis() + "," + thread.getName() + ",运行结束!");
                System.out.println(System.currentTimeMillis() + "," + thread.getName() + ",当前可用许可数量:" + semaphore.availablePermits());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10; i++) {
            new T("t-" + i).start();
        }
    }
}
```

输出：

```java
1563716603924,t-0,获取许可!
1563716603924,t-1,获取许可!
1563716606925,t-0,运行结束!
1563716606925,t-0,当前可用许可数量:0
1563716606925,t-1,运行结束!
1563716606925,t-1,当前可用许可数量:0
```

上面程序运行后一直无法结束，观察一下代码，代码中获取许可后，没有释放许可的代码，最终导致，可用许可数量为0，其他线程无法获取许可，会在`semaphore.acquire();`处等待，导致程序无法结束。



##### Demo3：释放许可证的正确姿势

示例1中，在finally里面释放锁，会有问题么？

如果获取锁的过程中发生异常，导致获取锁失败，最后finally里面也释放了许可，最终会怎么样，导致许可数量凭空增长了。

###### 第一种：使用变量控制

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.TreeMap;
import java.util.concurrent.Semaphore;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName SemaphoreTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description Semaphore信号量 正确释放许可证
 * @Version 1.0
 */
@Slf4j(topic = "c.SemaphoreTest3")
public class SemaphoreTest3 {

    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(1);

        Thread t1 = new Thread(() -> {
            boolean  acquireSuccess = false;

            try {
                semaphore.acquire();
                acquireSuccess = true;
                log.info("当前线程；" + Thread.currentThread().getName() + ",获取许可证");
                log.info("当前可用许可证数量：" + semaphore.availablePermits());
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (acquireSuccess){
                    semaphore.release();
                    log.info("当前线程；" + Thread.currentThread().getName() + ",释放许可证");
                }

            }
            log.info("当前可用许可证数量：" + semaphore.availablePermits());
        }, "t1");


        Thread t2 = new Thread(() -> {
            boolean  acquireSuccess = false;

            try {
                semaphore.acquire();
                acquireSuccess = true;
                log.info("当前线程；" + Thread.currentThread().getName() + ",获取许可证");
                log.info("当前可用许可证数量：" + semaphore.availablePermits());
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (acquireSuccess){
                    semaphore.release();
                    log.info("当前线程；" + Thread.currentThread().getName() + ",释放许可证");
                }
            }
            log.info("当前可用许可证数量：" + semaphore.availablePermits());
        }, "t2");

        t1.start();
        Thread.sleep(1000);

        t2.start();
        Thread.sleep(1000);
        t2.interrupt();




    }
}

```

输出：

```java
14:02:42.750 c.SemaphoreTest3 [t1] - 当前线程；t1,获取许可证
14:02:42.751 c.SemaphoreTest3 [t1] - 当前可用许可证数量：0
java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:998)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
	at java.util.concurrent.Semaphore.acquire(Semaphore.java:312)
	at cn.itcast.test.SemaphoreTest3.lambda$main$1(SemaphoreTest3.java:49)
	at java.lang.Thread.run(Thread.java:745)
14:02:44.757 c.SemaphoreTest3 [t2] - 当前可用许可证数量：0
14:02:47.765 c.SemaphoreTest3 [t1] - 当前线程；t1,释放许可证
14:02:47.765 c.SemaphoreTest3 [t1] - 当前可用许可证数量：1
```

###### 第二种：规定时间内获取许可证

使用tryAcquire() 带时间参数

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName SemaphoreTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description Semaphore信号量 正确释放许可证
 * @Version 1.0
 */
@Slf4j(topic = "c.SemaphoreTest4")
public class SemaphoreTest4 {

    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(1);

        Thread t1 = new Thread(() -> {
            boolean  acquireSuccess = false;

            try {
                acquireSuccess= semaphore.tryAcquire(1, TimeUnit.SECONDS);
                log.info("当前线程；" + Thread.currentThread().getName() + ",获取许可证");
                log.info("当前可用许可证数量：" + semaphore.availablePermits());
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (acquireSuccess){
                    semaphore.release();
                    log.info("当前线程；" + Thread.currentThread().getName() + ",释放许可证");
                }

            }
            log.info("当前可用许可证数量：" + semaphore.availablePermits());
        }, "t1");


        Thread t2 = new Thread(() -> {
            boolean  acquireSuccess = false;

            try {
                acquireSuccess= semaphore.tryAcquire(1, TimeUnit.SECONDS);
                log.info("当前线程；" + Thread.currentThread().getName() + ",获取许可证");
                log.info("当前可用许可证数量：" + semaphore.availablePermits());
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (acquireSuccess){
                    semaphore.release();
                    log.info("当前线程；" + Thread.currentThread().getName() + ",释放许可证");
                }
            }
            log.info("当前可用许可证数量：" + semaphore.availablePermits());
        }, "t2");

        t1.start();
        Thread.sleep(1000);

        t2.start();
        Thread.sleep(1000);
        t2.interrupt();




    }
}

```

输出：

```java
14:05:55.648 c.SemaphoreTest4 [t1] - 当前线程；t1,获取许可证
14:05:55.649 c.SemaphoreTest4 [t1] - 当前可用许可证数量：0
14:05:57.660 c.SemaphoreTest4 [t2] - 当前线程；t2,获取许可证
14:05:57.660 c.SemaphoreTest4 [t2] - 当前可用许可证数量：0
14:05:57.660 c.SemaphoreTest4 [t2] - 当前可用许可证数量：0
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at cn.itcast.test.SemaphoreTest4.lambda$main$1(SemaphoreTest4.java:51)
	at java.lang.Thread.run(Thread.java:745)
14:06:00.661 c.SemaphoreTest4 [t1] - 当前线程；t1,释放许可证
14:06:00.661 c.SemaphoreTest4 [t1] - 当前可用许可证数量：1
```



##### 其它补充说明

1. Semaphore默认创建的是非公平的信号量，什么意思呢？这个涉及到公平与非公平。举个例子：5个车位，允许5个车辆进去，来了100辆车，只能进去5辆，其他95在外面排队等着。里面刚好出来了1辆，此时刚好又来了10辆车，这10辆车是直接插队到其他95辆前面去，还是到95辆后面去排队呢？排队就表示公平，直接去插队争抢第一个，就表示不公平。对于停车场，排队肯定更好一些咯。不过对于信号量来说不公平的效率更高一些，所以默认是不公平的。
2. 建议阅读以下Semaphore的源码，对常用的方法有个了解，不需要都记住，用的时候也方便查询就好。
3. 方法中带有`throws InterruptedException`声明的，表示这个方法会响应线程中断信号，什么意思？表示调用线程的`interrupt()`方法，会让这些方法触发`InterruptedException`异常，即使这些方法处于阻塞状态，也会立即返回，并抛出`InterruptedException`异常，线程中断信号也会被清除。

### 12.9CountDownLatch

##### CountDownLatch介绍

CountDownLatch称之为闭锁，它可以使一个或一批线程在闭锁上等待，等到其他线程执行完相应操作后，闭锁打开，这些等待的线程才可以继续执行。确切的说，闭锁在内部维护了一个倒计数器。通过该计数器的值来决定闭锁的状态，从而决定是否允许等待的线程继续执行。

**常用方法：**

**public CountDownLatch(int count)**：构造方法，count表示计数器的值，不能小于0，否者会报异常。

**public void await() throws InterruptedException**：调用await()会让当前线程等待，直到计数器为0的时候，方法才会返回，此方法会响应线程中断操作。

**public boolean await(long timeout, TimeUnit unit) throws InterruptedException**：限时等待，在超时之前，计数器变为了0，方法返回true，否者直到超时，返回false，此方法会响应线程中断操作。

**public void countDown()**：让计数器减1

CountDownLatch使用步骤：

1. 创建CountDownLatch对象
2. 调用其实例方法`await()`，让当前线程等待
3. 调用`countDown()`方法，让计数器减1
4. 当计数器变为0的时候，`await()`方法会返回

##### CountDownLatch 使用

###### Demo1: 使用join 等待所有线程完成

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName CountDownLatchTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description 使用join 等待所有线程完成
 * @Version 1.0
 */
@Slf4j(topic = "c.CountDownLatchTest1")
public class CountDownLatchTest1 {
    public static void main(String[] args) throws InterruptedException {
        long l = System.currentTimeMillis();

        Thread t1 = new Thread(() -> {
            long start = System.currentTimeMillis();
            log.info("当前线程：" + Thread.currentThread().getName()+"开始");
            try {
                //模拟业务执行时间
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("当前线程：" + Thread.currentThread().getName()+"结束 执行时间：" + (System.currentTimeMillis() - start));


        }, "t1");


        Thread t2 = new Thread(() -> {
            long start = System.currentTimeMillis();
            log.info("当前线程：" + Thread.currentThread().getName()+"开始");
            try {
                //模拟业务执行时间
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("当前线程：" + Thread.currentThread().getName()+"结束 执行时间：" + (System.currentTimeMillis() - start));

        }, "t2");

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        log.info("当前线程：" + Thread.currentThread().getName()+"结束 执行时间：" + (System.currentTimeMillis() - l));
    }
}

```

输出：

```java
16:15:37.014 c.CountDownLatchTest1 [t2] - 当前线程：t2开始
16:15:37.014 c.CountDownLatchTest1 [t1] - 当前线程：t1开始
16:15:38.024 c.CountDownLatchTest1 [t2] - 当前线程：t2结束 执行时间：1011
16:15:38.024 c.CountDownLatchTest1 [t1] - 当前线程：t1结束 执行时间：1011
16:15:38.024 c.CountDownLatchTest1 [main] - 当前线程：main结束 执行时间：1036

```

代码中启动了2个解析sheet的线程，第一个耗时2秒，第二个耗时5秒，最终结果中总耗时：5秒。上面的关键技术点是线程的`join()`方法，此方法会让当前线程等待被调用的线程完成之后才能继续。可以看一下join的源码，内部其实是在synchronized方法中调用了线程的wait方法，最后被调用的线程执行完毕之后，由jvm自动调用其notifyAll()方法，唤醒所有等待中的线程。这个notifyAll()方法是由jvm内部自动调用的，jdk源码中是看不到的，需要看jvm源码，有兴趣的同学可以去查一下。所以JDK不推荐在线程上调用wait、notify、notifyAll方法。

而在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能。



###### Demo2：使用CountDownlatch实现等待线程结束

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName CountDownLatchTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description 使用CountDownLatch等待所有线程完成
 * @Version 1.0
 */
@Slf4j(topic = "c.CountDownLatchTest2")
public class CountDownLatchTest2 {
    public static class T extends Thread {
        //休眠时间（秒）
        int sleepSeconds;
        CountDownLatch countDownLatch;
        public T(String name, int sleepSeconds, CountDownLatch countDownLatch) {
            super(name);
            this.sleepSeconds = sleepSeconds;
            this.countDownLatch = countDownLatch;
        }
        @Override
        public void run() {
            Thread ct = Thread.currentThread();
            long startTime = System.currentTimeMillis();
            System.out.println(startTime + "," + ct.getName() + ",开始处理!");
            try {
                //模拟耗时操作，休眠sleepSeconds秒
                TimeUnit.SECONDS.sleep(this.sleepSeconds);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                countDownLatch.countDown();
            }
            long endTime = System.currentTimeMillis();
            System.out.println(endTime + "," + ct.getName() + ",处理完毕,耗时:" + (endTime - startTime));
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + "线程 start!");
        CountDownLatch countDownLatch = new CountDownLatch(2);
        long starTime = System.currentTimeMillis();
        T t1 = new T("解析sheet1线程", 2, countDownLatch);
        t1.start();
        T t2 = new T("解析sheet2线程", 5, countDownLatch);
        t2.start();
        countDownLatch.await();
        System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + "线程 end!");
        long endTime = System.currentTimeMillis();
        System.out.println("总耗时:" + (endTime - starTime));

    }
}

```

输出；

```java
1653985030583,main线程 start!
1653985030584,解析sheet2线程,开始处理!
1653985030584,解析sheet1线程,开始处理!
1653985032597,解析sheet1线程,处理完毕,耗时:2013
1653985035599,解析sheet2线程,处理完毕,耗时:5015
1653985035599,main线程 end!
总耗时:5015
```

从结果中看出，效果和join实现的效果一样，代码中创建了计数器为2的`CountDownLatch`，主线程中调用`countDownLatch.await();`会让主线程等待，t1、t2线程中模拟执行耗时操作，最终在finally中调用了`countDownLatch.countDown();`,此方法每调用一次，CountDownLatch内部计数器会减1，当计数器变为0的时候，主线程中的await()会返回，然后继续执行。注意：上面的`countDown()`这个是必须要执行的方法，所以放在finally中执行。



###### Demo3：等待指定时间

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName CountDownLatchTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description 使用CountDownLatch等待所有线程完成  等地指定时间内
 * @Version 1.0
 */
@Slf4j(topic = "c.CountDownLatchTest3")
public class CountDownLatchTest3 {
    public static class T extends Thread {
        //休眠时间（秒）
        int sleepSeconds;
        CountDownLatch countDownLatch;
        public T(String name, int sleepSeconds, CountDownLatch countDownLatch) {
            super(name);
            this.sleepSeconds = sleepSeconds;
            this.countDownLatch = countDownLatch;
        }
        @Override
        public void run() {
            Thread ct = Thread.currentThread();
            long startTime = System.currentTimeMillis();
            System.out.println(startTime + "," + ct.getName() + ",开始处理!");
            try {
                //模拟耗时操作，休眠sleepSeconds秒
                TimeUnit.SECONDS.sleep(this.sleepSeconds);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                countDownLatch.countDown();
            }
            long endTime = System.currentTimeMillis();
            System.out.println(endTime + "," + ct.getName() + ",处理完毕,耗时:" + (endTime - startTime));
        }
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + "线程 start!");
        CountDownLatch countDownLatch = new CountDownLatch(2);
        long starTime = System.currentTimeMillis();
        T t1 = new T("解析sheet1线程", 2, countDownLatch);
        t1.start();
        T t2 = new T("解析sheet2线程", 5, countDownLatch);
        t2.start();
        countDownLatch.await(3,TimeUnit.SECONDS);
        System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + "线程 end!");
        long endTime = System.currentTimeMillis();
        System.out.println("总耗时:" + (endTime - starTime));
       
    }
}

```

输出：

```java
1653985141502,main线程 start!
1653985141502,解析sheet1线程,开始处理!
1653985141503,解析sheet2线程,开始处理!
1653985143506,解析sheet1线程,处理完毕,耗时:2004
1653985144516,main线程 end!
总耗时:3014
1653985146512,解析sheet2线程,处理完毕,耗时:5009
```

从输出结果中可以看出，线程2耗时了5秒，主线程耗时了2秒，主线程中调用`countDownLatch.await(2, TimeUnit.SECONDS);`，表示最多等2秒，不管计数器是否为0，await方法都会返回，若等待时间内，计数器变为0了，立即返回true，否则超时后返回false。

###### 手写一个并行处理工具类

```java
package cn.itcast.test;

import lombok.extern.slf4j.Slf4j;
import org.omg.CORBA.PRIVATE_MEMBER;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import javax.management.remote.JMXPrincipal;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @ProjectName juc
 * @Package cn.itcast.test
 * @ClassName CountDownLatchTest1
 * @Author ZCC
 * @Date 2022/05/31
 * @Description 使用CountDownLatch 封装一个并行处理工具类
 * @Version 1.0
 */
@Slf4j(topic = "c.CountDownLatchTest4")
public class CountDownLatchTest4 {

    public static void main(String[] args) throws InterruptedException {
        //生成1-10的10个数字，放在list中，相当于10个任务
        List<Integer> list = Stream.iterate(1, a -> a + 1).limit(10).collect(Collectors.toList());
        //启动多线程处理list中的数据，每个任务休眠时间为list中的数值
        TaskDisposeUtils.dispose(list, item -> {
            try {
                long startTime = System.currentTimeMillis();
                TimeUnit.SECONDS.sleep(item);
                long endTime = System.currentTimeMillis();
                System.out.println(System.currentTimeMillis() + ",任务" + item + "执行完毕，耗时:" + (endTime - startTime));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        //上面所有任务处理完毕完毕之后，程序才能继续
        System.out.println(list + "中的任务都处理完毕!");
    }


}


class TaskDisposeUtils {
    private static final int POOL_SIZE;

    static {
        POOL_SIZE = Integer.max(Runtime.getRuntime().availableProcessors(), 5);
    }


    /**
     * 并行处理，并等待结束
     *
     * @param taskList 任务列表
     * @param consumer 消费者
     * @param <T>
     * @throws InterruptedException
     */
    public static <T> void dispose(List<T> taskList, Consumer<T> consumer) throws InterruptedException {
        dispose(true, POOL_SIZE, taskList, consumer);
    }


    /**
     * 并行处理，并等待结束
     *
     * @param moreThread 是否多线程执行
     * @param poolSize   线程池大小
     * @param taskList   任务列表
     * @param consumer   消费者
     * @param <T>
     * @throws InterruptedException
     */
    public static <T> void dispose(boolean moreThread, int poolSize, List<T> taskList, Consumer<T> consumer) throws InterruptedException {
        if (CollectionUtils.isEmpty(taskList)) {
            return;

        }
        if (moreThread && poolSize > 0) {
            poolSize = Math.min(poolSize, taskList.size());
            ExecutorService executorService = null;

            try {
                executorService = Executors.newFixedThreadPool(taskList.size());
                final CountDownLatch countDownLatch = new CountDownLatch(taskList.size());
                for (T item : taskList) {
                    executorService.execute(() -> {
                        try {

                            consumer.accept(item);
                        } finally {

                            countDownLatch.countDown();


                        }

                    });

                }
                countDownLatch.await();

            } finally {
                if (executorService != null) {
                    executorService.shutdown();

                }
            }

        } else {
            for (T item : taskList) {
                consumer.accept(item);
            }
        }

    }

}

```

**TaskDisposeUtils是一个并行处理的工具类，可以传入n个任务内部使用线程池进行处理，等待所有任务都处理完成之后，方法才会返回。比如我们发送短信，系统中有1万条短信，我们使用上面的工具，每次取100条并行发送，待100个都处理完毕之后，再取一批按照同样的逻辑发送。**

### 12.10CyclicBarrier

##### CyclicBarrier简介

CyclicBarrier通常称为循环屏障。它和CountDownLatch很相似，都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示：

```
public CyclicBarrier(int parties) {    this(parties, null);}
```

每调用一次await()方法都将使阻塞的线程数+1，只有阻塞的线程数达到设定值时屏障才会打开，允许阻塞的所有线程继续执行。除此之外，CyclicBarrier还有几点需要注意的地方:

- CyclicBarrier的计数器可以重置而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障循环二字的语义所在。
- CyclicBarrier允许用户自定义barrierAction操作，这是个可选操作，可以在创建CyclicBarrier对象时指定

```
public CyclicBarrier(int parties, Runnable barrierAction) {    if (parties <= 0) throw new IllegalArgumentException();    this.parties = parties;    this.count = parties;    this.barrierCommand = barrierAction;}
```

一旦用户在创建CyclicBarrier对象时设置了barrierAction参数，则在阻塞线程数达到设定值屏障打开前，会调用barrierAction的run()方法完成用户自定义的操作。

###### 示例1：简单使用CyclicBarrier

公司组织旅游，大家都有经历过，10个人，中午到饭点了，需要等到10个人都到了才能开饭，先到的人坐那等着，代码如下：

```
package com.itsoku.chat15;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;/** * 微信公众号：javacode2018，获取年薪50万java课程 */public class Demo1 {    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);    public static class T extends Thread {        int sleep;        public T(String name, int sleep) {            super(name);            this.sleep = sleep;        }        @Override        public void run() {            try {                //模拟休眠                TimeUnit.SECONDS.sleep(sleep);                long starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                cyclicBarrier.await();                long endTime = System.currentTimeMillis();                System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),开始吃饭了！");            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 1; i <= 10; i++) {            new T("员工" + i, i).start();        }    }}
```

输出：

```
员工1,sleep:1 等待了9000(ms),开始吃饭了！员工9,sleep:9 等待了1000(ms),开始吃饭了！员工8,sleep:8 等待了2001(ms),开始吃饭了！员工7,sleep:7 等待了3001(ms),开始吃饭了！员工6,sleep:6 等待了4001(ms),开始吃饭了！员工4,sleep:4 等待了6000(ms),开始吃饭了！员工5,sleep:5 等待了5000(ms),开始吃饭了！员工10,sleep:10 等待了0(ms),开始吃饭了！员工2,sleep:2 等待了7999(ms),开始吃饭了！员工3,sleep:3 等待了7000(ms),开始吃饭了！
```

代码中模拟了10个员工上桌吃饭的场景，等待所有员工都到齐了才能开发，可以看到第10个员工最慢，前面的都在等待第10个员工，员工1等待了9秒，上面代码中调用`cyclicBarrier.await();`会让当前线程等待。当10个员工都调用了`cyclicBarrier.await();`之后，所有处于等待中的员工都会被唤醒，然后继续运行。

###### 示例2：循环使用CyclicBarrier

对示例1进行改造一下，吃饭完毕之后，所有人都去车上，待所有人都到车上之后，驱车去下一景点玩。

```
package com.itsoku.chat15;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;/** * 微信公众号：javacode2018，获取年薪50万java课程 */public class Demo2 {    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);    public static class T extends Thread {        int sleep;        public T(String name, int sleep) {            super(name);            this.sleep = sleep;        }        //等待吃饭        void eat() {            try {                //模拟休眠                TimeUnit.SECONDS.sleep(sleep);                long starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                cyclicBarrier.await();                long endTime = System.currentTimeMillis();                System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),开始吃饭了！");                //休眠sleep时间，模拟当前员工吃饭耗时                TimeUnit.SECONDS.sleep(sleep);            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            }        }        //等待所有人到齐之后，开车去下一站        void drive() {            try {                long starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                cyclicBarrier.await();                long endTime = System.currentTimeMillis();                System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),去下一景点的路上！");            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            }        }        @Override        public void run() {            //等待所有人到齐之后吃饭，先到的人坐那等着，什么事情不要干            this.eat();            //等待所有人到齐之后开车去下一景点，先到的人坐那等着，什么事情不要干            this.drive();        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 1; i <= 10; i++) {            new T("员工" + i, i).start();        }    }}
```

输出：

```
员工10,sleep:10 等待了0(ms),开始吃饭了！员工5,sleep:5 等待了5000(ms),开始吃饭了！员工6,sleep:6 等待了4000(ms),开始吃饭了！员工9,sleep:9 等待了1001(ms),开始吃饭了！员工4,sleep:4 等待了6000(ms),开始吃饭了！员工3,sleep:3 等待了7000(ms),开始吃饭了！员工1,sleep:1 等待了9001(ms),开始吃饭了！员工2,sleep:2 等待了8000(ms),开始吃饭了！员工8,sleep:8 等待了2001(ms),开始吃饭了！员工7,sleep:7 等待了3000(ms),开始吃饭了！员工10,sleep:10 等待了0(ms),去下一景点的路上！员工1,sleep:1 等待了8998(ms),去下一景点的路上！员工5,sleep:5 等待了4999(ms),去下一景点的路上！员工4,sleep:4 等待了5999(ms),去下一景点的路上！员工3,sleep:3 等待了6998(ms),去下一景点的路上！员工2,sleep:2 等待了7998(ms),去下一景点的路上！员工9,sleep:9 等待了999(ms),去下一景点的路上！员工8,sleep:8 等待了1999(ms),去下一景点的路上！员工7,sleep:7 等待了2999(ms),去下一景点的路上！员工6,sleep:6 等待了3999(ms),去下一景点的路上！
```

坑，又是员工10最慢，要提升效率了，不能吃的太多，得减肥。

代码中CyclicBarrier相当于使用了2次，第一次用于等待所有人到达后开饭，第二次用于等待所有人上车后驱车去下一景点。注意一些先到的员工会在其他人到达之前，都处于等待状态（`cyclicBarrier.await();`会让当前线程阻塞），无法干其他事情，等到最后一个人到了会唤醒所有人，然后继续。

> CyclicBarrier内部相当于有个计数器（构造方法传入的），每次调用`await();`后，计数器会减1，并且await()方法会让当前线程阻塞，等待计数器减为0的时候，所有在await()上等待的线程被唤醒，然后继续向下执行，此时计数器又会被还原为创建时的值，然后可以继续再次使用。

###### 示例3：最后到的人给大家上酒，然后开饭

还是示例1中的例子，员工10是最后到达的，让所有人都久等了，那怎么办，得给所有人倒酒，然后开饭，代码如下：

```
package com.itsoku.chat15;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;/** * 微信公众号：javacode2018，获取年薪50万java课程 */public class Demo3 {    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10, () -> {        //模拟倒酒，花了2秒，又得让其他9个人等2秒        try {            TimeUnit.SECONDS.sleep(2);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + "说，不好意思，让大家久等了，给大家倒酒赔罪!");    });    public static class T extends Thread {        int sleep;        public T(String name, int sleep) {            super(name);            this.sleep = sleep;        }        @Override        public void run() {            try {                //模拟休眠                TimeUnit.SECONDS.sleep(sleep);                long starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                cyclicBarrier.await();                long endTime = System.currentTimeMillis();                System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),开始吃饭了！");            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 1; i <= 10; i++) {            new T("员工" + i, i).start();        }    }}
```

输出：

```
员工10说，不好意思，让大家久等了，给大家倒酒赔罪!员工10,sleep:10 等待了2000(ms),开始吃饭了！员工1,sleep:1 等待了11000(ms),开始吃饭了！员工2,sleep:2 等待了10000(ms),开始吃饭了！员工5,sleep:5 等待了7000(ms),开始吃饭了！员工7,sleep:7 等待了5000(ms),开始吃饭了！员工9,sleep:9 等待了3000(ms),开始吃饭了！员工4,sleep:4 等待了8000(ms),开始吃饭了！员工3,sleep:3 等待了9001(ms),开始吃饭了！员工8,sleep:8 等待了4001(ms),开始吃饭了！员工6,sleep:6 等待了6001(ms),开始吃饭了！
```

代码中创建`CyclicBarrier`对象时，多传入了一个参数（内部是倒酒操作），先到的人先等待，待所有人都到齐之后，需要先给大家倒酒，然后唤醒所有等待中的人让大家开饭。从输出结果中我们发现，倒酒操作是由最后一个人操作的，最后一个人倒酒完毕之后，才唤醒所有等待中的其他员工，让大家开饭。

###### 示例4：其中一个人等待中被打断了

员工5等待中，突然接了个电话，有点急事，然后就拿起筷子开吃了，其他人会怎么样呢？看着他吃么？

代码如下：

```
package com.itsoku.chat15;import java.sql.Time;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;/** * 微信公众号：javacode2018，获取年薪50万java课程 */public class Demo4 {    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);    public static class T extends Thread {        int sleep;        public T(String name, int sleep) {            super(name);            this.sleep = sleep;        }        @Override        public void run() {            long starTime = 0, endTime = 0;            try {                //模拟休眠                TimeUnit.SECONDS.sleep(sleep);                starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                System.out.println(this.getName() + "到了！");                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            }            endTime = System.currentTimeMillis();            System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),开始吃饭了！");        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 1; i <= 10; i++) {            int sleep = 0;            if (i == 10) {                sleep = 10;            }            T t = new T("员工" + i, sleep);            t.start();            if (i == 5) {                //模拟员工5接了个电话，将自己等待吃饭给打断了                TimeUnit.SECONDS.sleep(1);                System.out.println(t.getName() + ",有点急事，我先开干了！");                t.interrupt();                TimeUnit.SECONDS.sleep(2);            }        }    }}
```

输出：

```
员工4到了！员工3到了！员工5到了！员工1到了！员工2到了！员工5,有点急事，我先开干了！java.util.concurrent.BrokenBarrierException员工1,sleep:0 等待了1001(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)员工3,sleep:0 等待了1001(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工4,sleep:0 等待了1001(ms),开始吃饭了！    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工2,sleep:0 等待了1001(ms),开始吃饭了！员工5,sleep:0 等待了1002(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.lang.InterruptedException    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.reportInterruptAfterWait(AbstractQueuedSynchronizer.java:2014)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2048)    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:234)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException员工6到了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工9到了！    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工8到了！员工7到了！员工6,sleep:0 等待了0(ms),开始吃饭了！员工7,sleep:0 等待了1(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工8,sleep:0 等待了1(ms),开始吃饭了！员工9,sleep:0 等待了1(ms),开始吃饭了！Disconnected from the target VM, address: '127.0.0.1:64413', transport: 'socket'java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)员工10到了！员工10,sleep:10 等待了0(ms),开始吃饭了！
```

输出的信息看着有点乱，给大家理一理，员工5遇到急事，拿起筷子就是吃，这样好么，当然不好，他这么做了，后面看他这么做了都跟着这么做（这种场景是不是很熟悉，有一个人拿起筷子先吃起来，其他人都跟着上了），直接不等其他人了，拿起筷子就开吃了。CyclicBarrier遇到这种情况就是这么处理的。前面4个员工都在`await()`处等待着，员工5也在`await()`上等待着，等了1秒（`TimeUnit.SECONDS.sleep(1);`），接了个电话，然后给员工5发送中断信号后（`t.interrupt();`），员工5的await()方法会触发`InterruptedException`异常，此时其他等待中的前4个员工，看着5开吃了，自己立即也不等了，内部从`await()`方法中触发`BrokenBarrierException`异常，然后也开吃了，后面的6/7/8/9/10员工来了以后发现大家都开吃了，自己也不等了，6-10员工调用`await()`直接抛出了`BrokenBarrierException`异常，然后继续向下。

**结论：**

1. **内部有一个人把规则破坏了（接收到中断信号），其他人都不按规则来了，不会等待了**
2. **接收到中断信号的线程，await方法会触发InterruptedException异常，然后被唤醒向下运行**
3. **其他等待中 或者后面到达的线程，会在await()方法上触发`BrokenBarrierException`异常，然后继续执行**

###### 示例5：其中一个人只愿意等的5秒

基于示例1，员工1只愿意等的5秒，5s后如果大家还没到期，自己要开吃了，员工1开吃了，其他人会怎么样呢？

```
package com.itsoku.chat15;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;/** * 微信公众号：javacode2018，获取年薪50万java课程 */public class Demo5 {    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);    public static class T extends Thread {        int sleep;        public T(String name, int sleep) {            super(name);            this.sleep = sleep;        }        @Override        public void run() {            long starTime = 0, endTime = 0;            try {                //模拟休眠                TimeUnit.SECONDS.sleep(sleep);                starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                System.out.println(this.getName() + "到了！");                if (this.getName().equals("员工1")) {                    cyclicBarrier.await(5, TimeUnit.SECONDS);                } else {                    cyclicBarrier.await();                }            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            } catch (TimeoutException e) {                e.printStackTrace();            }            endTime = System.currentTimeMillis();            System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),开始吃饭了！");        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 1; i <= 10; i++) {            T t = new T("员工" + i, i);            t.start();        }    }}
```

输出：

```
员工1到了！员工2到了！员工3到了！员工4到了！员工5到了！员工6到了！员工1,sleep:1 等待了5001(ms),开始吃饭了！员工5,sleep:5 等待了1001(ms),开始吃饭了！java.util.concurrent.TimeoutException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:32)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)员工6,sleep:6 等待了2(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException员工2,sleep:2 等待了4002(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)员工3,sleep:3 等待了3001(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工4,sleep:4 等待了2001(ms),开始吃饭了！    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException员工7到了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)员工7,sleep:7 等待了0(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)员工8到了！员工8,sleep:8 等待了0(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)员工9到了！java.util.concurrent.BrokenBarrierException员工9,sleep:9 等待了0(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)java.util.concurrent.BrokenBarrierException员工10到了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)员工10,sleep:10 等待了0(ms),开始吃饭了！    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)
```

从输出结果中我们可以看到：1等待5秒之后，开吃了，其他等待人都开吃了，后面来的人不等待，直接开吃了。

员工1调用有参`await`方法等待5秒之后，触发了`TimeoutException`异常，然后继续向下运行，其他的在5开吃之前已经等了一会的的几个员工，他们看到5开吃了，自己立即不等待了，也也开吃了（他们的`await`抛出了`BrokenBarrierException`异常）；还有几个员工在5开吃之后到达的，他们直接不等待了，直接抛出`BrokenBarrierException`异常，然后也开吃了。

**结论：**

1. **等待超时的方法**

   ```
   public int await(long timeout, TimeUnit unit) throws InterruptedException,BrokenBarrierException,TimeoutException
   ```

2. **内部有一个人把规则破坏了（等待超时），其他人都不按规则来了，不会等待了**

3. **等待超时的线程，await方法会触发TimeoutException异常，然后被唤醒向下运行**

4. **其他等待中 或者后面到达的线程，会在await()方法上触发`BrokenBarrierException`异常，然后继续执行**

###### 示例6：重建规则

示例5中改造一下，员工1等待5秒超时之后，开吃了，打破了规则，先前等待中的以及后面到达的都不按规则来了，都拿起筷子开吃。过了一会，导游重新告知大家，要按规则来，然后重建了规则，大家都按规则来了。

代码如下：

```
package com.itsoku.chat15;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;/** * 微信公众号：javacode2018，获取年薪50万java课程 */public class Demo6 {    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);    //规则是否已重建    public static boolean guizhe = false;    public static class T extends Thread {        int sleep;        public T(String name, int sleep) {            super(name);            this.sleep = sleep;        }        @Override        public void run() {            long starTime = 0, endTime = 0;            try {                //模拟休眠                TimeUnit.SECONDS.sleep(sleep);                starTime = System.currentTimeMillis();                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续                System.out.println(this.getName() + "到了！");                if (!guizhe) {                    if (this.getName().equals("员工1")) {                        cyclicBarrier.await(5, TimeUnit.SECONDS);                    } else {                        cyclicBarrier.await();                    }                } else {                    cyclicBarrier.await();                }            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            } catch (TimeoutException e) {                e.printStackTrace();            }            endTime = System.currentTimeMillis();            System.out.println(this.getName() + ",sleep:" + this.sleep + " 等待了" + (endTime - starTime) + "(ms),开始吃饭了！");        }    }    public static void main(String[] args) throws InterruptedException {        for (int i = 1; i <= 10; i++) {            T t = new T("员工" + i, i);            t.start();        }        //等待10秒之后，重置，重建规则        TimeUnit.SECONDS.sleep(15);        cyclicBarrier.reset();        guizhe = true;        System.out.println("---------------大家太皮了，请大家按规则来------------------");        //再来一次        for (int i = 1; i <= 10; i++) {            T t = new T("员工" + i, i);            t.start();        }    }}
```

输出：

```
员工1到了！员工2到了！员工3到了！员工4到了！员工5到了！java.util.concurrent.TimeoutException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:36)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)员工6到了！员工1,sleep:1 等待了5002(ms),开始吃饭了！员工6,sleep:6 等待了4(ms),开始吃饭了！员工4,sleep:4 等待了2004(ms),开始吃饭了！员工5,sleep:5 等待了1004(ms),开始吃饭了！员工3,sleep:3 等待了3002(ms),开始吃饭了！员工2,sleep:2 等待了4004(ms),开始吃饭了！员工7到了！员工7,sleep:7 等待了0(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)员工8到了！员工8,sleep:8 等待了0(ms),开始吃饭了！java.util.concurrent.BrokenBarrierException员工9到了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)员工9,sleep:9 等待了0(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)java.util.concurrent.BrokenBarrierException员工10到了！    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)员工10,sleep:10 等待了0(ms),开始吃饭了！    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)---------------大家太皮了，请大家按规则来------------------员工1到了！员工2到了！员工3到了！员工4到了！员工5到了！员工6到了！员工7到了！员工8到了！员工9到了！员工10到了！员工10,sleep:10 等待了0(ms),开始吃饭了！员工1,sleep:1 等待了9000(ms),开始吃饭了！员工2,sleep:2 等待了8000(ms),开始吃饭了！员工3,sleep:3 等待了6999(ms),开始吃饭了！员工7,sleep:7 等待了3000(ms),开始吃饭了！员工6,sleep:6 等待了4000(ms),开始吃饭了！员工5,sleep:5 等待了5000(ms),开始吃饭了！员工4,sleep:4 等待了6000(ms),开始吃饭了！员工9,sleep:9 等待了999(ms),开始吃饭了！员工8,sleep:8 等待了1999(ms),开始吃饭了！
```

第一次规则被打乱了，过了一会导游重建了规则（`cyclicBarrier.reset();`），接着又重来来了一次模拟等待吃饭的操作，正常了。

##### CountDownLatch和CyclicBarrier的区别

还是举例子说明一下：

**CountDownLatch示例**

主管相当于 **CountDownLatch**，干活的小弟相当于做事情的线程。

老板交给主管了一个任务，让主管搞完之后立即上报给老板。主管下面有10个小弟，接到任务之后将任务划分为10个小任务分给每个小弟去干，主管一直处于等待状态（主管会调用`await()`方法，此方法会阻塞当前线程），让每个小弟干完之后通知一下主管（调用`countDown()`方法通知主管，此方法会立即返回），主管等到所有的小弟都做完了，会被唤醒，从await()方法上苏醒，然后将结果反馈给老板。期间主管会等待，会等待所有小弟将结果汇报给自己。

**而CyclicBarrier是一批线程让自己等待，等待所有的线程都准备好了，自己才能继续。**

好了，上面举了6个例子便于大家熟悉`CyclicBarrier`的用法，喜欢的帮忙转发一下，谢谢！

### 13 线程池

#### 什么是线程池？

大家用jdbc操作过数据库应该知道，操作数据库需要和数据库建立连接，拿到连接之后才能操作数据库，用完之后销毁。数据库连接的创建和销毁其实是比较耗时的，真正和业务相关的操作耗时是比较短的。每个数据库操作之前都需要创建连接，为了提升系统性能，后来出现了数据库连接池，系统启动的时候，先创建很多连接放在池子里面，使用的时候，直接从连接池中获取一个，使用完毕之后返回到池子里面，继续给其他需要者使用，这其中就省去创建连接的时间，从而提升了系统整体的性能。

线程池和数据库连接池的原理也差不多，创建线程去处理业务，可能创建线程的时间比处理业务的时间还长一些，如果系统能够提前为我们创建好线程，我们需要的时候直接拿来使用，用完之后不是直接将其关闭，而是将其返回到线程中中，给其他需要这使用，这样直接节省了创建和销毁的时间，提升了系统的性能。

简单的说，在使用了线程池之后，创建线程变成了从线程池中获取一个空闲的线程，然后使用，关闭线程变成了将线程归还到线程池。



#### 线程池原理

当向线程池提交一个任务之后，线程池的处理流程如下：

1. 判断是否达到核心线程数，若未达到，则直接创建新的线程处理当前传入的任务，否则进入下个流程
2. 线程池中的工作队列是否已满，若未满，则将任务丢入工作队列中先存着等待处理，否则进入下个流程
3. 是否达到最大线程数，若未达到，则创建新的线程处理当前传入的任务，否则交给线程池中的饱和策略进行处理。

流程图：

```flow
st=>start: 开始
cond1=>condition: 核心线程是否已满?
cond2=>condition: 工作队列是否已满？
cond3=>condition: 是否超过最大线程数？
op1=>operation: 按照策略处理新来的任务
op2=>operation: 创建线程执行任务
op3=>operation: 将任务放在队列中
op4=>operation: 创建线程执行任务

st->cond1
cond1(yes)->cond2
cond2(yes)->cond3
cond3(yes)->op1
cond3(no)->op4
cond2(no)->op3
cond1(no)->op2

```



#### 线程池核心参数

jdk中提供了线程池的具体实现，实现类是：`java.util.concurrent.ThreadPoolExecutor`，主要构造方法：

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```

- **corePoolSize**：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的`prestartAllCoreThreads`方法，线程池会提前把核心线程都创造好，并启动
- **maximumPoolSize**：线程池允许创建的最大线程数。如果队列满了，并且以创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果我们使用了无界队列，那么所有的任务会加入队列，这个参数就没有什么效果了
- **keepAliveTime**：线程池的工作线程空闲后，保持存活的时间。如果没有任务处理了，有些线程会空闲，空闲的时间超过了这个值，会被回收掉。如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率
- **unit**：keepAliveTIme的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举`java.util.concurrent.TimeUnit`，这个枚举也经常使用，有兴趣的可以看一下其源码
- **workQueue**：工作队列，用于缓存待处理任务的阻塞队列，常见的有4种
  - **ArrayBlockingQueue**：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序
  - **LinkedBlockingQueue**：是一个基于链表结构的阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法`Executors.newFixedThreadPool`使用了这个队列。
  - **SynchronousQueue** ：一个不存储元素的阻塞队列，每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法`Executors.newCachedThreadPool`使用这个队列
  - **PriorityBlockingQueue**：优先级队列，进入队列的元素按照优先级会进行排序
- **threadFactory**：线程池中创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字
- **handler**：饱和策略，当线程池无法处理新来的任务了，那么需要提供一种策略处理提交的新任务，默认有4种策略
  - **AbortPolicy**：直接抛出异常
  - **CallerRunsPolicy**：在当前调用者的线程中运行任务，即随丢来的任务，由他自己去处理
  - **DiscardOldestPolicy**：丢弃队列中最老的一个任务，即丢弃队列头部的一个任务，然后执行当前传入的任务
  - **DiscardPolicy**：不处理，直接丢弃掉，方法内部为空



**调用线程池的execute方法处理任务，执行execute方法的过程：**

1. 判断线程池中运行的线程数是否小于corepoolsize，是：则创建新的线程来处理任务，否：执行下一步
2. 试图将任务添加到workQueue指定的队列中，如果无法添加到队列，进入下一步
3. 判断线程池中运行的线程数是否小于`maximumPoolSize`，是：则新增线程处理当前传入的任务，否：将任务传递给`handler`对象`rejectedExecution`方法处理

**线程池的使用步骤：**

1. 调用构造方法创建线程池
2. 调用线程池的方法处理任务
3. 关闭线程池



#### 线程池中常见5种工作队列

任务太多的时候，工作队列用于暂时缓存待处理的任务，jdk中常见的5种阻塞队列：

**ArrayBlockingQueue**：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序

**LinkedBlockingQueue**：是一个基于链表结构的阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法`Executors.newFixedThreadPool`使用了这个队列。

**SynchronousQueue** ：一个不存储元素的阻塞队列，每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法`Executors.newCachedThreadPool`使用这个队列

**PriorityBlockingQueue**：优先级队列，进入队列的元素按照优先级会进行排序

前2种队列相关示例就不说了，主要说一下后面2种队列的使用示例。



##### SynchronousQueue队列的线程池

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName SynchronousQueueTest
 * @Author ZCC
 * @Date 2022/06/01
 * @Description SynchronousQueue 同步队列测试
 * @Version 1.0
 */
@Slf4j(topic = "c.SynchronousQueueTest")
public class SynchronousQueueTest {
    static ExecutorService executor = Executors.newCachedThreadPool();

    public static void main(String[] args) {
        for (int i = 0; i < 50; i++) {
            int j = i;
            String taskName = "任务" + j;
            executor.execute(() -> {
                System.out.println(Thread.currentThread().getName() + "处理" + taskName);
                //模拟任务内部处理耗时
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        executor.shutdown();
    }
}

```

输出：

```java
pool-1-thread-1处理任务0
pool-1-thread-9处理任务8
pool-1-thread-4处理任务3
pool-1-thread-3处理任务2
pool-1-thread-11处理任务10
pool-1-thread-2处理任务1
pool-1-thread-8处理任务7
pool-1-thread-5处理任务4
pool-1-thread-6处理任务5
pool-1-thread-12处理任务11
pool-1-thread-13处理任务12
pool-1-thread-7处理任务6
pool-1-thread-10处理任务9
pool-1-thread-14处理任务13
pool-1-thread-15处理任务14
pool-1-thread-16处理任务15
pool-1-thread-17处理任务16
pool-1-thread-18处理任务17
pool-1-thread-19处理任务18
pool-1-thread-20处理任务19
pool-1-thread-22处理任务21
pool-1-thread-21处理任务20
pool-1-thread-23处理任务22
pool-1-thread-24处理任务23
```

代码中使用`Executors.newCachedThreadPool()`创建线程池，看一下的源码：

```
public static ExecutorService newCachedThreadPool() {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                      60L, TimeUnit.SECONDS,                                      new SynchronousQueue<Runnable>());    }
```

从输出中可以看出，系统创建了50个线程处理任务，代码中使用了`SynchronousQueue`同步队列，这种队列比较特殊，放入元素必须要有另外一个线程去获取这个元素，否则放入元素会失败或者一直阻塞在那里直到有线程取走，示例中任务处理休眠了指定的时间，导致已创建的工作线程都忙于处理任务，所以新来任务之后，将任务丢入同步队列会失败，丢入队列失败之后，会尝试新建线程处理任务。使用上面的方式创建线程池需要注意，如果需要处理的任务比较耗时，会导致新来的任务都会创建新的线程进行处理，可能会导致创建非常多的线程，最终耗尽系统资源，触发OOM。



##### PriorityBlockingQueue优先级队列的线程池

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;
import sun.rmi.runtime.Log;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName PriorityBlockingQueueTest
 * @Author ZCC
 * @Date 2022/06/01
 * @Description PriorityBlockingQueue 线程优先级队列测试
 * @Version 1.0
 */
@Slf4j(topic = "c.PriorityBlockingQueueTest")
public class PriorityBlockingQueueTest {
    static ExecutorService executor = new ThreadPoolExecutor(
            1,
            1,
            60L, TimeUnit.SECONDS,
            new PriorityBlockingQueue());

    public static void main(String[] args) {

        for (int i = 0; i < 10; i++) {
            String taskName = "任务" + i;
            executor.execute(new Task(i, taskName));
        }
        for (int i = 100; i >= 90; i--) {
            String taskName = "任务" + i;
            executor.execute(new Task(i, taskName));
        }
        executor.shutdown();
    }
}






@Slf4j(topic = "c.Task")
class Task implements Runnable, Comparable<Task> {

    private int i;
    private String name;

    public Task(int i, String name) {
        this.i = i;
        this.name = name;
    }

    @Override
    public int compareTo(Task o) {
        return Integer.compare(o.i, this.i);
    }

    @Override
    public void run() {
        log.info(Thread.currentThread().getName() + "处理" + this.name);
    }
}
```

输出：

```java
16:04:49.713 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务0
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务100
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务99
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务98
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务97
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务96
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务95
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务94
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务93
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务92
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务91
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务90
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务9
16:04:49.715 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务8
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务7
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务6
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务5
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务4
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务3
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务2
16:04:49.716 c.Task [pool-1-thread-1] - pool-1-thread-1处理任务1
```

输出中，除了第一个任务，其他任务按照优先级高低按顺序处理。原因在于：创建线程池的时候使用了优先级队列，进入队列中的任务会进行排序，任务的先后顺序由Task中的i变量决定。向`PriorityBlockingQueue`加入元素的时候，内部会调用代码中Task的`compareTo`方法决定元素的先后顺序。



#### 4种常见饱和策略

当线程池中队列已满，并且线程池已达到最大线程数，线程池会将任务传递给饱和策略进行处理。这些策略都实现了`RejectedExecutionHandler`接口。接口中有个方法：

```
void rejectedExecution(Runnable r, ThreadPoolExecutor executor)
```

> 参数说明：
>
> **r**：需要执行的任务
>
> **executor**：当前线程池对象

JDK中提供了4种常见的饱和策略:

**AbortPolicy**：直接抛出异常

**CallerRunsPolicy**：在当前调用者的线程中运行任务，即随丢来的任务，由他自己去处理

**DiscardOldestPolicy**：丢弃队列中最老的一个任务，即丢弃队列头部的一个任务，然后执行当前传入的任务

**DiscardPolicy**：不处理，直接丢弃掉，方法内部为空



#### 自定义线程创建工厂

给线程池中线程起一个有意义的名字，在系统出现问题的时候，通过线程堆栈信息可以更容易发现系统中问题所在。自定义创建工厂需要实现`java.util.concurrent.ThreadFactory`接口中的`Thread newThread(Runnable r)`方法，参数为传入的任务，需要返回一个工作线程。

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName CustomThreadFactory
 * @Author ZCC
 * @Date 2022/06/01
 * @Description 自定义创建线程的工厂 需要实现ThreadFactory接口
 * @Version 1.0
 */
@Slf4j(topic = "c.CustomThreadFactory")
public class CustomThreadFactory {
    static AtomicInteger threadNum = new AtomicInteger(1);
    static ThreadPoolExecutor executor = new ThreadPoolExecutor(5,
            5, 10,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(10),
            r -> {
                Thread thread = new Thread(r);
                thread.setName("自定义线程创建工厂-" + threadNum.getAndIncrement());

                return thread;
            });

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            String taskName = "任务-" + i;
            executor.execute(() -> {
               log.info(Thread.currentThread().getName() + "处理" + taskName);
            });
        }
        executor.shutdown();

    }
}

```

输出：

```java
16:06:11.780 c.CustomThreadFactory [自定义线程创建工厂-5] - 自定义线程创建工厂-5处理任务-4
16:06:11.780 c.CustomThreadFactory [自定义线程创建工厂-3] - 自定义线程创建工厂-3处理任务-2
16:06:11.780 c.CustomThreadFactory [自定义线程创建工厂-1] - 自定义线程创建工厂-1处理任务-0
16:06:11.780 c.CustomThreadFactory [自定义线程创建工厂-2] - 自定义线程创建工厂-2处理任务-1
16:06:11.780 c.CustomThreadFactory [自定义线程创建工厂-4] - 自定义线程创建工厂-4处理任务-3
```

#### 自定义饱和策略

需要实现`RejectedExecutionHandler`接口。任务无法处理的时候，我们想记录一下日志，我们需要自定义一个饱和策略

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName CustomRejectedExecutionHandler
 * @Author ZCC
 * @Date 2022/06/01
 * @Description 自定义饱和策略 需要实现RejectedExecutionHandler接口
 * @Version 1.0
 */
@Slf4j(topic = "c.CustomRejectedExecutionHandler")
public class CustomRejectedExecutionHandler {
    static ThreadPoolExecutor executor = new ThreadPoolExecutor(5,
            5,
            5,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(1),
            Executors.defaultThreadFactory(),
            (r, executors) -> {
                //自定义饱和策略
                //记录一下无法处理的任务
                log.info("无法处理的任务：" + r.toString());
            });

    public static void main(String[] args) {
        for (int i = 0; i <= 11; i++) {
            executor.execute(() -> {
                log.info(Thread.currentThread().getName() + "处理");
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });

        }

        executor.shutdown();

    }

}

```

输出

```java
16:09:13.278 c.CustomRejectedExecutionHandler [main] - 无法处理的任务：cn.itcast.executor.CustomRejectedExecutionHandler$$Lambda$2/457233904@19bb089b
16:09:13.278 c.CustomRejectedExecutionHandler [pool-1-thread-2] - pool-1-thread-2处理
16:09:13.278 c.CustomRejectedExecutionHandler [pool-1-thread-1] - pool-1-thread-1处理
16:09:13.278 c.CustomRejectedExecutionHandler [pool-1-thread-5] - pool-1-thread-5处理
16:09:13.278 c.CustomRejectedExecutionHandler [pool-1-thread-4] - pool-1-thread-4处理
16:09:13.278 c.CustomRejectedExecutionHandler [pool-1-thread-3] - pool-1-thread-3处理
16:09:13.280 c.CustomRejectedExecutionHandler [main] - 无法处理的任务：cn.itcast.executor.CustomRejectedExecutionHandler$$Lambda$2/457233904@19bb089b
16:09:13.280 c.CustomRejectedExecutionHandler [main] - 无法处理的任务：cn.itcast.executor.CustomRejectedExecutionHandler$$Lambda$2/457233904@19bb089b
16:09:13.280 c.CustomRejectedExecutionHandler [main] - 无法处理的任务：cn.itcast.executor.CustomRejectedExecutionHandler$$Lambda$2/457233904@19bb089b
16:09:13.280 c.CustomRejectedExecutionHandler [main] - 无法处理的任务：cn.itcast.executor.CustomRejectedExecutionHandler$$Lambda$2/457233904@19bb089b
16:09:13.280 c.CustomRejectedExecutionHandler [main] - 无法处理的任务：cn.itcast.executor.CustomRejectedExecutionHandler$$Lambda$2/457233904@19bb089b
16:09:18.287 c.CustomRejectedExecutionHandler [pool-1-thread-5] - pool-1-thread-5处理
```

输出结果中可以看到有3个任务进入了饱和策略中，记录了任务的日志，对于无法处理多任务，我们最好能够记录一下，让开发人员能够知道。任务进入了饱和策略，说明线程池的配置可能不是太合理，或者机器的性能有限，需要做一些优化调整。

#### 线程池中的2个关闭方法

线程池提供了2个关闭方法：`shutdown`和`shutdownNow`，当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。调用者两个方法中任意一个，线程池的`isShutdown`方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用`isTerminaed`方法会返回true。

调用`shutdown`方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。

而调用`shutdownNow`方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。

至于调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用`shutdown`方法来关闭线程池，如果任务不一定要执行完，则可以调用`shutdownNow`方法。



#### 线程池扩展方法

虽然jdk提供了`ThreadPoolExecutor`这个高性能线程池，但是如果我们自己想在这个线程池上面做一些扩展，比如，监控每个任务执行的开始时间，结束时间，或者一些其他自定义的功能，我们应该怎么办？

这个jdk已经帮我们想到了，`ThreadPoolExecutor`内部提供了几个方法`beforeExecute`、`afterExecute`、`terminated`，可以由开发人员自己去这些方法。看一下线程池内部的源码：

```java
try {
    beforeExecute(wt, task);//任务执行之前调用的方法
    Throwable thrown = null;
    try {
        task.run();
    } catch (RuntimeException x) {
        thrown = x;
        throw x;
    } catch (Error x) {
        thrown = x;
        throw x;
    } catch (Throwable x) {
        thrown = x;
        throw new Error(x);
    } finally {
        afterExecute(task, thrown);//任务执行完毕之后调用的方法
    }
} finally {
    task = null;
    w.completedTasks++;
    w.unlock();
}
```

**beforeExecute：任务执行之前调用的方法，有2个参数，第1个参数是执行任务的线程，第2个参数是任务**

```
protected void beforeExecute(Thread t, Runnable r) { }
```

**afterExecute：任务执行完成之后调用的方法，2个参数，第1个参数表示任务，第2个参数表示任务执行时的异常信息，如果无异常，第二个参数为null**

```
protected void afterExecute(Runnable r, Throwable t) { }
```

**terminated：线程池最终关闭之后调用的方法。所有的工作线程都退出了，最终线程池会退出，退出时调用该方法**

demo:

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName ExtendEXecuteros
 * @Author ZCC
 * @Date 2022/06/01
 * @Description 线程池扩展
 * @Version 1.0
 */
@Slf4j(topic = "c.ExtendExecutuor")
public class ExtendExecutuor {
    static ThreadPoolExecutor executor = new ThreadPoolExecutor(5,
            5,
            5,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(1),
            Executors.defaultThreadFactory(),
            (r, executors) -> {
                //自定义饱和策略
                //记录一下无法处理的任务
                log.info("无法处理的任务：" + r.toString());
            }) {
        @Override
        protected void beforeExecute(Thread t, Runnable r) {
            System.out.println(System.currentTimeMillis() + "," + t.getName() + ",开始执行任务:" + r.toString());
        }

        @Override
        protected void afterExecute(Runnable r, Throwable t) {
            System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",任务:" + r.toString() + "，执行完毕!");
        }

        @Override
        protected void terminated() {
            System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + "，关闭线程池!");
        }
    };

    public static void main(String[] args) throws InterruptedException {

        for (int i = 0; i < 5; i++) {
            String taskName = "任务-" + i;
            executor.execute(() -> {
                log.info(Thread.currentThread().getName() + "处理" + taskName);
            });
        }
        TimeUnit.SECONDS.sleep(1);
        executor.shutdown();

       
    }
}

```

输出：

```java
1654071146310,pool-1-thread-1,开始执行任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@346ee862
1654071146310,pool-1-thread-3,开始执行任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@395bc6b9
1654071146310,pool-1-thread-4,开始执行任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@2ccc711e
1654071146310,pool-1-thread-2,开始执行任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@3dfb2bb9
1654071146311,pool-1-thread-5,开始执行任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@1d6d101c
16:12:26.311 c.ExtendExecutuor [pool-1-thread-2] - pool-1-thread-2处理任务-1
16:12:26.311 c.ExtendExecutuor [pool-1-thread-1] - pool-1-thread-1处理任务-0
1654071146313,pool-1-thread-2,任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@3dfb2bb9，执行完毕!
16:12:26.311 c.ExtendExecutuor [pool-1-thread-5] - pool-1-thread-5处理任务-4
1654071146313,pool-1-thread-1,任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@346ee862，执行完毕!
16:12:26.311 c.ExtendExecutuor [pool-1-thread-4] - pool-1-thread-4处理任务-3
1654071146313,pool-1-thread-5,任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@1d6d101c，执行完毕!
1654071146313,pool-1-thread-4,任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@2ccc711e，执行完毕!
16:12:26.311 c.ExtendExecutuor [pool-1-thread-3] - pool-1-thread-3处理任务-2
1654071146313,pool-1-thread-3,任务:cn.itcast.executor.ExtendExecutuor$$Lambda$2/1321640594@395bc6b9，执行完毕!
1654071147311,pool-1-thread-3，关闭线程池!

```

从输出结果中可以看到，每个需要执行的任务打印了3行日志，执行前由线程池的`beforeExecute`打印，执行时会调用任务的`run`方法，任务执行完毕之后，会调用线程池的`afterExecute`方法，从每个任务的首尾2条日志中可以看到每个任务耗时2秒左右。线程池最终关闭之后调用了`terminated`方法。



#### 如何合理的配置线程池？

要想合理的配置线程池，需要先分析任务的特性，可以冲一下几个角度分析：

- 任务的性质：CPU密集型任务、IO密集型任务和混合型任务
- 任务的优先级：高、中、低
- 任务的执行时间：长、中、短
- 任务的依赖性：是否依赖其他的系统资源，如数据库连接。

性质不同任务可以用不同规模的线程池分开处理。CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。由于IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：cup数量*2。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。可以通过`Runtime.getRuntime().availableProcessors()`方法获取cpu数量。优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行。

使用队列的时候建议使用有界队列，有界队列增加了系统的稳定性，如果采用无解队列，任务太多的时候可能导致系统OOM，直接让系统宕机。

##### 线程池中线程数量的配置

线程池汇总线程大小对系统的性能有一定的影响，我们的目标是希望系统能够发挥最好的性能，过多或者过小的线程数量无法有消息的使用机器的性能。咋Java Concurrency inPractice书中给出了估算线程池大小的公式：

```java
Ncpu = CUP的数量
Ucpu = 目标CPU的使用率，0<=Ucpu<=1
W/C = 等待时间与计算时间的比例
为保存处理器达到期望的使用率，最有的线程池的大小等于：
Nthreads = Ncpu × Ucpu × (1+W/C)
```

#### 其它补充

##### 一些使用建议

在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。



##### 看cpu的核数 

```java
System.out.println(Runtime.getRuntime().availableProcessors());
```



##### ThreadPoolTaskExecutor 其他知识点汇总(待补充)

1. **线程池中的所有线程超过了空闲时间都会被销毁么？**

   如果allowCoreThreadTimeOut为true，超过了空闲时间的所有线程都会被回收，不过这个值默认是false，系统会保留核心线程，其他的会被回收

2. **空闲线程是如何被销毁的？**

   所有运行的工作线程会尝试从队列中获取任务去执行，超过一定时间（keepAliveTime）还没有拿到任务，自己主动退出

3. **核心线程在线程池创建的时候会初始化好么？**

   默认情况下，核心线程不会进行初始化，在刚开始调用线程池执行任务的时候，传入一个任务会创建一个线程，直到达到核心线程数。不过可以在创建线程池之后，调用其`prestartAllCoreThreads`提前将核心线程创建好。

   

### juc Executors详情



**Excecutor框架主要包含3部分的内容：**

1. 任务相关的：包含被执行的任务要实现的接口：**Runnable**接口或**Callable**接口
2. 任务的执行相关的：包含任务执行机制的**核心接口Executor**，以及继承自`Executor`的`ExecutorService`接口。Executor框架中有两个关键的类实现了ExecutorService接口（`ThreadPoolExecutor`和`ScheduledThreadPoolExecutor`）
3. 异步计算结果相关的：包含**接口Future**和**实现Future接口的FutureTask类**



**Executors框架包括：**

- Executor
- ExecutorService
- ThreadPoolExecutor
- Executors
- Future
- Callable
- FutureTask
- CompletableFuture
- CompletionService
- ExecutorCompletionService



#### Executor接口

Executor接口中定义了方法execute(Runable able)接口，该方法接受一个Runable实例，他来执行一个任务，任务即实现一个Runable接口的类。

#### ExecutorService接口

ExecutorService继承于Executor接口，他提供了更为丰富的线程实现方法，比如ExecutorService提供关闭自己的方法，以及为跟踪一个或多个异步任务执行状况而生成Future的方法。

ExecutorService有三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了shutdown()方法时，便进入了关闭状态，此时意味着ExecutorService不再接受新的任务，但是他还是会执行已经提交的任务，当所有已经提交了的任务执行完后，便达到终止状态。如果不调用shutdown方法，ExecutorService方法会一直运行下去，系统一般不会主动关闭。

#### ThreadPoolExecutor类

线程池类，实现了`ExecutorService`接口中所有方法，该类也是我们经常要用到的



#### ScheduledThreadPoolExecutor定时器

ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，他主要用来延迟执行任务，或者定时执行任务。功能和Timer类似，但是ScheduledThreadPoolExecutor更强大、更灵活一些。Timer后台是单个线程，而ScheduledThreadPoolExecutor可以在创建的时候指定多个线程。

常用方法介绍：

##### schedule:延迟执行任务1次

使用`ScheduledThreadPoolExecutor的schedule方法`，看一下这个方法的声明：

```
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)
```

> 3个参数：
>
> command：需要执行的任务
>
> delay：需要延迟的时间
>
> unit：参数2的时间单位，是个枚举，可以是天、小时、分钟、秒、毫秒、纳秒等

实例代码：

```java
package cn.itcast.executor;

import javafx.scene.input.DataFormat;
import jdk.internal.dynalink.beans.StaticClass;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName ScheduledThreadPoolExecutor
 * @Author ZCC
 * @Date 2022/06/01
 * @Description 定时任务线程
 * @Version 1.0
 */
@Slf4j(topic = "c.ExtendExecutuor")
public class ScheduledThreadPoolExecutor {
   static ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);


    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        log.info(dateTimeFormatter.format(now));
        scheduledExecutorService.schedule(()->{
            log.info(System.currentTimeMillis() + "开始执行");
            //模拟任务耗时
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info(System.currentTimeMillis() + "执行结束");

        },3,TimeUnit.SECONDS);

        scheduledExecutorService.shutdown();
    }
}

```

输出：

```java
13:39:28.139 c.ExtendExecutuor [main] - 2022-06-02 13:39:28
13:39:31.147 c.ExtendExecutuor [pool-1-thread-1] - 1654148371147开始执行
13:39:34.150 c.ExtendExecutuor [pool-1-thread-1] - 1654148374150执行结束
```





#### Executors类

Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。常用的方法有：

**newSingleThreadExecutor**

```
public static ExecutorService newSingleThreadExecutor()public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)
```

> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。内部使用了无限容量的LinkedBlockingQueue阻塞队列来缓存任务，任务如果比较多，单线程如果处理不过来，会导致队列堆满，引发OOM。

**newFixedThreadPool**

```
public static ExecutorService newFixedThreadPool(int nThreads)public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)
```

> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，在提交新任务，任务将会进入等待队列中等待。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。内部使用了无限容量的LinkedBlockingQueue阻塞队列来缓存任务，任务如果比较多，如果处理不过来，会导致队列堆满，引发OOM。

**newCachedThreadPool**

```
public static ExecutorService newCachedThreadPool()public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)
```

> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，
>
> 那么就会回收部分空闲（60秒处于等待任务到来）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池的最大值是Integer的最大值(2^31-1)。内部使用了SynchronousQueue同步队列来缓存任务，此队列的特性是放入任务时必须要有对应的线程获取任务，任务才可以放入成功。如果处理的任务比较耗时，任务来的速度也比较快，会创建太多的线程引发OOM。

**newScheduledThreadPool**

```
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)
```

> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。



#### Future、Callable接口

`Future`接口定义了操作异步异步任务执行一些方法，**如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕**等。

`Callable`接口中定义了需要有返回的任务需要实现的方法。

```
@FunctionalInterfacepublic interface Callable<V> {    V call() throws Exception;}
```

比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。



##### 获取异步任务执行结果

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName FutureTest
 * @Author ZCC
 * @Date 2022/06/02
 * @Description 获取异步任务执行结果 Future
 * @Version 1.0
 */
@Slf4j(topic = "c.FutureTest")
public class FutureTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
         ExecutorService executors = Executors.newFixedThreadPool(10);

        Future<Integer> submit = executors.submit(() -> {
            log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",start!");
            TimeUnit.SECONDS.sleep(5);
            log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",end!");

            return 10;

        });
        log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName());
       log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",结果：" + submit.get());
       executors.shutdown();
    }

}
```

输出：

```java
14:03:49.573 c.FutureTest [main] - 1654149829572,main
14:03:49.573 c.FutureTest [pool-1-thread-1] - 1654149829572,pool-1-thread-1,start!
14:03:54.575 c.FutureTest [pool-1-thread-1] - 1654149834575,pool-1-thread-1,end!
14:03:54.575 c.FutureTest [main] - 1654149829574,main,结果：10
```

代码中创建了一个线程池，调用线程池的`submit`方法执行任务，submit参数为`Callable`接口：表示需要执行的任务有返回值，submit方法返回一个`Future`对象，Future相当于一个凭证，可以在任意时间拿着这个凭证去获取对应任务的执行结果（调用其`get`方法），代码中调用了`result.get()`方法之后，此方法会阻塞当前线程直到任务执行结束。



##### 超时获取异步任务执行结果

可能任务执行比较耗时，比如耗时1分钟，我最多只能等待10秒，如果10秒还没返回，我就去做其他事情了。

刚好get有个超时的方法，声明如下：

```java
V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;
```

demo:

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName FutureTest
 * @Author ZCC
 * @Date 2022/06/02
 * @Description 获取异步任务执行结果 Future
 * @Version 1.0
 */
@Slf4j(topic = "c.FutureTest")
public class FutureTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
         ExecutorService executors = Executors.newFixedThreadPool(10);

        Future<Integer> submit = executors.submit(() -> {
            log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",start!");
            TimeUnit.SECONDS.sleep(5);
            log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",end!");

            return 10;

        });
        log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName());
       log.info(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",结果：" + submit.get(2,TimeUnit.SECONDS));
       executors.shutdown();
    }

}

```

输出：

```java
14:42:03.511 c.FutureTest [main] - 1654152123510,main
14:42:03.511 c.FutureTest [pool-1-thread-1] - 1654152123510,pool-1-thread-1,start!
Exception in thread "main" java.util.concurrent.TimeoutException
	at java.util.concurrent.FutureTask.get(FutureTask.java:205)
	at cn.itcast.executor.FutureTest.main(FutureTest.java:31)
14:42:08.514 c.FutureTest [pool-1-thread-1] - 1654152128514,pool-1-thread-1,end!

```



**`Future`其他方法介绍一下**

**cancel**：取消在执行的任务，参数表示是否对执行的任务发送中断信号，方法声明如下：

```
boolean cancel(boolean mayInterruptIfRunning);
```

**isCancelled**：用来判断任务是否被取消

**isDone**：判断任务是否执行完毕。

**cancel方法来个示例：**

```
package com.itsoku.chat18;import java.util.concurrent.*;/** * 跟着阿里p7学并发，微信公众号：javacode2018 */public class Demo7 {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(1);        Future<Integer> result = executorService.submit(() -> {            System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName()+",start!");            TimeUnit.SECONDS.sleep(5);            System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName()+",end!");            return 10;        });        executorService.shutdown();        TimeUnit.SECONDS.sleep(1);        result.cancel(false);        System.out.println(result.isCancelled());        System.out.println(result.isDone());        TimeUnit.SECONDS.sleep(5);        System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName());        System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName() + ",结果：" + result.get());        executorService.shutdown();    }}
```

输出：

```
1564583031646,pool-1-thread-1,start!truetrue1564583036649,pool-1-thread-1,end!1564583037653,mainException in thread "main" java.util.concurrent.CancellationException    at java.util.concurrent.FutureTask.report(FutureTask.java:121)    at java.util.concurrent.FutureTask.get(FutureTask.java:192)    at com.itsoku.chat18.Demo7.main(Demo7.java:24)
```

输出2个true，表示任务已被取消，已完成，最后调用get方法会触发`CancellationException`异常。

**总结：从上面可以看出Future、Callable接口需要结合ExecutorService来使用，需要有线程池的支持。**

#### FutureTask类

FutureTask除了实现Future接口，还实现了Runnable接口，因此FutureTask可以交给Executor执行，也可以交给线程执行执行（**Thread有个Runnable的构造方法**），**FutureTask**表示带返回值结果的任务。

上面我们演示的是通过线程池执行任务然后获取执行结果。

这次我们通过FutureTask类，自己启动一个线程来获取执行结果，示例如下：

```
package com.itsoku.chat18;import java.util.concurrent.*;/** * 跟着阿里p7学并发，微信公众号：javacode2018 */public class Demo9 {    public static void main(String[] args) throws ExecutionException, InterruptedException {        FutureTask<Integer> futureTask = new FutureTask<Integer>(()->{            System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName()+",start!");            TimeUnit.SECONDS.sleep(5);            System.out.println(System.currentTimeMillis() + "," + Thread.currentThread().getName()+",end!");            return 10;        });        System.out.println(System.currentTimeMillis()+","+Thread.currentThread().getName());        new Thread(futureTask).start();        System.out.println(System.currentTimeMillis()+","+Thread.currentThread().getName());        System.out.println(System.currentTimeMillis()+","+Thread.currentThread().getName()+",结果:"+futureTask.get());    }}
```

输出：

```
1564585122547,main1564585122547,main1564585122547,Thread-0,start!1564585127549,Thread-0,end!1564585122547,main,结果:10
```

**大家可以回过头去看一下上面用线程池的submit方法返回的Future实际类型正是FutureTask对象，有兴趣的可以设置个断点去看看。**

**FutureTask类还是相当重要的，标记一下。**



#### CompletionService接口

CompletionService相当于一个执行任务的服务，通过submit丢任务给这个服务，服务内部去执行任务，可以通过服务提供的一些方法获取服务中已经完成的任务。

**接口内的几个方法：**

```
Future<V> submit(Callable<V> task);
```

> 用于向服务中提交有返回结果的任务，并返回Future对象

```
Future<V> submit(Runnable task, V result);
```

> 用户向服务中提交有返回值的任务去执行，并返回Future对象

```
Future<V> take() throws InterruptedException;
```

> 从服务中返回并移除一个已经完成的任务，如果获取不到，会一致阻塞到有返回值为止。此方法会响应线程中断。

```
Future<V> poll();
```

> 从服务中返回并移除一个已经完成的任务，如果内部没有已经完成的任务，则返回空，此方法会立即响应。

```
Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;
```

> 尝试在指定的时间内从服务中返回并移除一个已经完成的任务，等待的时间超时还是没有获取到已完成的任务，则返回空。此方法会响应线程中断

通过submit向内部提交任意多个任务，通过take方法可以获取已经执行完成的任务，如果获取不到将等待。

#### ExecutorCompletionService类

ExecutorCompletionService类是CompletionService接口的具体实现。

说一下其内部原理，ExecutorCompletionService创建的时候会传入一个线程池，调用submit方法传入需要执行的任务，任务由内部的线程池来处理；ExecutorCompletionService内部有个阻塞队列，任意一个任务完成之后，会将任务的执行结果（Future类型）放入阻塞队列中，然后其他线程可以调用它take、poll方法从这个阻塞队列中获取一个已经完成的任务，获取任务返回结果的顺序和任务执行完成的先后顺序一致，所以最先完成的任务会先返回。

看一下构造方法：

```
public ExecutorCompletionService(Executor executor) {        if (executor == null)            throw new NullPointerException();        this.executor = executor;        this.aes = (executor instanceof AbstractExecutorService) ?            (AbstractExecutorService) executor : null;        this.completionQueue = new LinkedBlockingQueue<Future<V>>();    }
```

构造方法需要传入一个Executor对象，这个对象表示任务执行器，所有传入的任务会被这个执行器执行。

`completionQueue`是用来存储任务结果的阻塞队列，默认用采用的是`LinkedBlockingQueue`，也支持开发自己设置。通过submit传入需要执行的任务，任务执行完成之后，会放入`completionQueue`中，有兴趣的可以看一下原码，还是很好理解的。



##### ExecutorCompletionService实战应用

###### 获取先完成任务的线程结果

可以用来获取先完成的任务结果

demo：

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName ExecutorCompletionServiceTest
 * @Author ZCC
 * @Date 2022/06/02
 * @Description ExecutorCompletionService  获取多线程情况先先完成的线程任务结果
 * @Version 1.0
 */
@Slf4j(topic = "c.ExecutorCompletionServiceTest")
public class ExecutorCompletionServiceTest {

    @Slf4j(topic = "c.GoodsModel")
    static class GoodsModel {
        //商品名称
        String name;
        //购物开始时间
        long startime;
        //送到的时间
        long endtime;

        public GoodsModel(String name, long startime, long endtime) {
            this.name = name;
            this.startime = startime;
            this.endtime = endtime;
        }

        @Override
        public String toString() {
            return name + "，下单时间[" + this.startime + "," + endtime + "]，耗时:" + (this.endtime - this.startime);
        }

    }

    /**
     * 将商品搬上楼
     *
     * @param goodsModel
     * @throws InterruptedException
     */
    static void moveUp(GoodsModel goodsModel) throws InterruptedException {
        //休眠5秒，模拟搬上楼耗时
        TimeUnit.SECONDS.sleep(5);
        log.info("将商品搬上楼，商品信息:" + goodsModel);
    }

    /**
     * 模拟下单
     *
     * @param name     商品名称
     * @param costTime 耗时
     * @return
     */
    static Callable<GoodsModel> buyGoods(String name, long costTime) {
        return () -> {
            long startTime = System.currentTimeMillis();
            log.info(startTime + "购买" + name + "下单!");
            //模拟送货耗时
            try {
                TimeUnit.SECONDS.sleep(costTime);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            long endTime = System.currentTimeMillis();
            log.info(endTime + name + "送到了!");
            return new GoodsModel(name, startTime, endTime);
        };
    }


    public static void main(String[] args) throws InterruptedException, ExecutionException {
        long st = System.currentTimeMillis();
        log.info(st + "开始购物!");
        ExecutorService executor = Executors.newFixedThreadPool(5);
        //创建ExecutorCompletionService对象
        ExecutorCompletionService<GoodsModel> executorCompletionService = new ExecutorCompletionService<>(executor);
        //异步下单购买冰箱
        executorCompletionService.submit(buyGoods("冰箱", 5));
        //异步下单购买洗衣机
        executorCompletionService.submit(buyGoods("洗衣机", 2));
        executor.shutdown();
        //购买商品的数量
        int goodsCount = 2;
        for (int i = 0; i < goodsCount; i++) {
            //可以获取到最先到的商品
            GoodsModel goodsModel = executorCompletionService.take().get();
            //将最先到的商品送上楼
            moveUp(goodsModel);
        }
        long et = System.currentTimeMillis();
        log.info(et + "货物已送到家里咯，哈哈哈！");
        log.info("总耗时:" + (et - st));

    }
}


```

输出：

```java
14:57:15.282 c.ExecutorCompletionServiceTest [main] - 1654153035281开始购物!
14:57:15.318 c.ExecutorCompletionServiceTest [pool-1-thread-1] - 1654153035318购买冰箱下单!
14:57:15.318 c.ExecutorCompletionServiceTest [pool-1-thread-2] - 1654153035318购买洗衣机下单!
14:57:17.320 c.ExecutorCompletionServiceTest [pool-1-thread-2] - 1654153037320洗衣机送到了!
14:57:20.320 c.ExecutorCompletionServiceTest [pool-1-thread-1] - 1654153040320冰箱送到了!
14:57:22.323 c.ExecutorCompletionServiceTest [main] - 将商品搬上楼，商品信息:洗衣机，下单时间[1654153035318,1654153037320]，耗时:2002
14:57:27.326 c.ExecutorCompletionServiceTest [main] - 将商品搬上楼，商品信息:冰箱，下单时间[1654153035318,1654153040320]，耗时:5002
14:57:27.326 c.ExecutorCompletionServiceTest [main] - 1654153047326货物已送到家里咯，哈哈哈！
14:57:27.326 c.ExecutorCompletionServiceTest [main] - 总耗时:12045
```

从输出中可以看出和我们希望的结果一致，代码中下单顺序是：冰箱、洗衣机，冰箱送货耗时5秒，洗衣机送货耗时2秒，洗衣机先到的，然后被送上楼了，冰箱后到被送上楼，总共耗时12秒，和期望的方案一样。

###### 执行一批任务，然后消费执行结果

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.*;
import java.util.function.Consumer;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName ExecutorCompletionServiceTest
 * @Author ZCC
 * @Date 2022/06/02
 * @Description ExecutorCompletionService  执行一批任务 然后消费结果
 * @Version 1.0
 */
@Slf4j(topic = "c.ExecutorCompletionServiceTest2")
public class ExecutorCompletionServiceTest2 {
    static ExecutorService executorService = Executors.newFixedThreadPool(10);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        List<Callable<Integer>> list = new ArrayList<>();
        int taskCount = 5;
        for (int i = taskCount; i > 0; i--) {
            int j = i * 2;
            list.add(() -> {
                TimeUnit.SECONDS.sleep(j);
                return j;
            });
        }
        solve(executorService, list, a -> {
           log.info(System.currentTimeMillis() + ":" + a);
        });
        executorService.shutdown();

    }


    public static <T> void solve(Executor executor, Collection<Callable<T>> solvers, Consumer<T> use) throws InterruptedException, ExecutionException {
        if (CollectionUtils.isEmpty(solvers)) {
            return;
        }
        ExecutorCompletionService<T> executorCompletionService = new ExecutorCompletionService<>(executor);
        for (Callable callable : solvers) {
            executorCompletionService.submit(callable);
        }

        int j = solvers.size();
        for (int i = 0; i < j; i++) {
            T t = executorCompletionService.take().get();
            if (t!=null){
                use.accept(t);
            }
        }

    }
}


```

输出

```java
15:23:57.434 c.ExecutorCompletionServiceTest2 [main] - 1654154637433:2
15:23:59.433 c.ExecutorCompletionServiceTest2 [main] - 1654154639433:4
15:24:01.433 c.ExecutorCompletionServiceTest2 [main] - 1654154641433:6
15:24:03.433 c.ExecutorCompletionServiceTest2 [main] - 1654154643433:8
15:24:05.432 c.ExecutorCompletionServiceTest2 [main] - 1654154645432:10
```

代码中传入了一批任务进行处理，最终将所有处理完成的按任务完成的先后顺序传递给`Consumer`进行消费了。



###### 异步执行一批任务，有一个完成立即返回，其他取消

**方式1：**

使用ExecutorCompletionService实现，ExecutorCompletionService提供了获取一批任务中最先完成的任务结果的能力。

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.*;
import java.util.function.Consumer;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName ExecutorCompletionServiceTest
 * @Author ZCC
 * @Date 2022/06/02
 * @Description ExecutorCompletionService 异步执行一批任务，有一个完成立即返回，其他取消
 * @Version 1.0
 */
@Slf4j(topic = "c.ExecutorCompletionServiceTest3")
public class ExecutorCompletionServiceTest3 {
    static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()+1);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long startime = System.currentTimeMillis();
        List<Callable<Integer>> list = new ArrayList<>();
        int taskCount = 5;
        for (int i = taskCount; i > 0; i--) {
            int j = i * 2;
            list.add(() -> {
                log.info(Thread.currentThread().getName()+"start");
                TimeUnit.SECONDS.sleep(j);
                log.info(Thread.currentThread().getName()+"end :" +j);
                return j;
            });

        }
        Integer integer = invokeAny(executorService, list);
       log.info("耗时:" + (System.currentTimeMillis() - startime) + ",执行结果:" + integer);

        executorService.shutdown();

    }

    public static <T> T invokeAny(Executor e, Collection<Callable<T>> solvers) {
        if (CollectionUtils.isEmpty(solvers)) {
            return null;
        }
        ExecutorCompletionService<T> executorCompletionService = new ExecutorCompletionService<>(e);
        List<Future<T>> futureList = new ArrayList<>();
        for (Callable callable : solvers) {
            futureList.add(executorCompletionService.submit(callable));

        }
        int j = solvers.size();

        for (int i = 0; i < j; i++) {
            try {
                T t = executorCompletionService.take().get();
                if (t != null) {
                    return t;

                }
            } catch (InterruptedException interruptedException) {
                interruptedException.printStackTrace();
            } catch (ExecutionException executionException) {
                executionException.printStackTrace();
            } finally {
                // 取消其它任务
                for (Future<T> future : futureList) {
                    future.cancel(true);

                }

            }
        }

        return null;

    }


}


```

输出

```java
15:53:17.392 c.ExecutorCompletionServiceTest3 [pool-1-thread-5] - pool-1-thread-5start
15:53:17.392 c.ExecutorCompletionServiceTest3 [pool-1-thread-3] - pool-1-thread-3start
15:53:17.392 c.ExecutorCompletionServiceTest3 [pool-1-thread-2] - pool-1-thread-2start
15:53:17.392 c.ExecutorCompletionServiceTest3 [pool-1-thread-4] - pool-1-thread-4start
15:53:17.392 c.ExecutorCompletionServiceTest3 [pool-1-thread-1] - pool-1-thread-1start
15:53:19.395 c.ExecutorCompletionServiceTest3 [pool-1-thread-5] - pool-1-thread-5end :2
15:53:19.395 c.ExecutorCompletionServiceTest3 [main] - 耗时:2039,执行结果:2
```

代码中执行了5个任务，使用CompletionService执行任务，调用take方法获取最先执行完成的任务，然后返回。在finally中对所有任务发送取消操作（`future.cancel(true);`），从输出中可以看出只有任务1执行成功，其他任务被成功取消了，符合预期结果。

**方式2：**

其实`ExecutorService`已经为我们提供了这样的方法，方法声明如下：

```java
<T> T invokeAny(Collection<? extends Callable<T>> tasks)        throws InterruptedException, ExecutionException;
```

demo

```java
package cn.itcast.executor;

import lombok.extern.slf4j.Slf4j;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.*;

/**
 * @ProjectName juc
 * @Package cn.itcast.executor
 * @ClassName ExecutorCompletionServiceTest
 * @Author ZCC
 * @Date 2022/06/02
 * @Description ExecutorCompletionService 异步执行一批任务，有一个完成立即返回，其他取消
 * @Version 1.0
 */
@Slf4j(topic = "c.ExecutorCompletionServiceTest3")
public class ExecutorCompletionServiceTest4 {
    static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long startime = System.currentTimeMillis();
        List<Callable<Integer>> list = new ArrayList<>();
        int taskCount = 5;
        for (int i = taskCount; i > 0; i--) {
            int j = i * 2;
            list.add(() -> {
                log.info(Thread.currentThread().getName() + "start");
                TimeUnit.SECONDS.sleep(j);
                log.info(Thread.currentThread().getName() + "end :" + j);
                return j;
            });

        }
        Integer integer = executorService.invokeAny(list);
        log.info("耗时:" + (System.currentTimeMillis() - startime) + ",执行结果:" + integer);
        executorService.shutdown();

    }


}


```

输出

```java
15:57:20.743 c.ExecutorCompletionServiceTest3 [pool-1-thread-4] - pool-1-thread-4start
15:57:20.743 c.ExecutorCompletionServiceTest3 [pool-1-thread-5] - pool-1-thread-5start
15:57:20.743 c.ExecutorCompletionServiceTest3 [pool-1-thread-3] - pool-1-thread-3start
15:57:20.743 c.ExecutorCompletionServiceTest3 [pool-1-thread-2] - pool-1-thread-2start
15:57:20.743 c.ExecutorCompletionServiceTest3 [pool-1-thread-1] - pool-1-thread-1start
15:57:22.748 c.ExecutorCompletionServiceTest3 [pool-1-thread-5] - pool-1-thread-5end :2
15:57:22.748 c.ExecutorCompletionServiceTest3 [main] - 耗时:2036,执行结果:2
```



### CAS

####  引入

**需求：我们开发了一个网站，需要对访问量进行统计，用户每次发一次请求，访问量+1，如何实现呢？**

##### demo1：

```java
package cn.itcast.cas;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;

/**
 * @ProjectName juc
 * @Package cn.itcast.cas
 * @ClassName CasTest1
 * @Author ZCC
 * @Date 2022/06/02
 * @Description java cas  模拟用户访问网站 统计网张毅用户访问总次数
 * @Version 1.0
 */
@Slf4j(topic = "c.CasTest1")
public class CasTest1 {
    static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);

    //访问次数
    static   int requestCount = 0;
    //模拟访问一次

    public static void request() throws InterruptedException {
        //模拟耗时5毫秒


        TimeUnit.MILLISECONDS.sleep(5);
        requestCount++;


    }

    public static void main(String[] args) throws InterruptedException {
        long starTime = System.currentTimeMillis();
        // 100个用户同时访问网站 每个用户访问十次
        int user = 100;
        CountDownLatch countDownLatch = new CountDownLatch(user);
        for (int i = 0; i < user; i++) {
            executorService.execute(() -> {
                //    模拟一个用户访问10次

                    boolean falg = false;
                    try {
                        for (int j = 0; j < 10; j++) {

                        request();
                            falg = true;
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {

                        if (falg) {

                            countDownLatch.countDown();
                        }
                    }




            });




        }

        countDownLatch.await();
        executorService.shutdown();
        long endTime = System.currentTimeMillis();
        log.info(Thread.currentThread().getName() + "，耗时：" + (endTime - starTime) + ",count=" + requestCount);
    }
}

```

输出：

```java
17:37:08.732 c.CasTest1 [main] - main，耗时：469,count=767
```

代码中的count用来记录总访问次数，`request()`方法表示访问一次，内部休眠5毫秒模拟内部耗时，request方法内部对count++操作。程序最终耗时1秒多，执行还是挺快的，但是count和我们期望的结果不一致，我们期望的是1000，实际输出的是973（每次运行结果可能都不一样）。

###### 分析

**代码中采用的是多线程的方式来操作count，count++会有线程安全问题，count++操作实际上是由以下三步操作完成的：**

1. 获取count的值，记做A：A=count
2. 将A的值+1，得到B：B = A+1
3. 让B赋值给count：count = B

如果有A、B两个线程同时执行count++，他们同时执行到上面步骤的第1步，得到的count是一样的，3步操作完成之后，count只会+1，导致count只加了一次，从而导致结果不准确。

**那么我们应该怎么做的呢？**

对count++操作的时候，我们让多个线程排队处理，多个线程同时到达request()方法的时候，只能允许一个线程可以进去操作，其他的线程在外面候着，等里面的处理完毕出来之后，外面等着的再进去一个，这样操作count++就是排队进行的，结果一定是正确的。

**我们前面学了synchronized、ReentrantLock可以对资源加锁，保证并发的正确性，多线程情况下可以保证被锁的资源被串行访问，那么我们用synchronized来实现一下。**



##### demo2:引入锁优化demo1

```java
package cn.itcast.cas;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName juc
 * @Package cn.itcast.cas
 * @ClassName CasTest1
 * @Author ZCC
 * @Date 2022/06/02
 * @Description java cas  模拟用户访问网站 统计网张毅用户访问总次数(使用synchronized)
 * @Version 1.0
 */
@Slf4j(topic = "c.CasTest1")
public class CasTest2 {
    static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);

    //访问次数
    static   int requestCount = 0;
    //模拟访问一次

    public static synchronized void  request() throws InterruptedException {
        //模拟耗时5毫秒


        TimeUnit.MILLISECONDS.sleep(5);
        requestCount++;


    }

    public static void main(String[] args) throws InterruptedException {
        long starTime = System.currentTimeMillis();
        // 100个用户同时访问网站 每个用户访问十次
        int user = 100;
        CountDownLatch countDownLatch = new CountDownLatch(user);
        for (int i = 0; i < user; i++) {
            executorService.execute(() -> {
                //    模拟一个用户访问10次

                    boolean falg = false;
                    try {
                        for (int j = 0; j < 10; j++) {

                        request();
                            falg = true;
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {

                        if (falg) {

                            countDownLatch.countDown();
                        }
                    }




            });




        }

        countDownLatch.await();
        executorService.shutdown();
        long endTime = System.currentTimeMillis();
        log.info(Thread.currentThread().getName() + "，耗时：" + (endTime - starTime) + ",count=" + requestCount);
    }
}
```

输出：

```java
17:40:58.438 c.CasTest1 [main] - main，耗时：5499,count=1000
```

程序中request方法使用synchronized关键字，保证了并发情况下，request方法同一时刻只允许一个线程访问，request加锁了相当于串行执行了，count的结果和我们预期的结果一致，只是耗时比较长，5秒多。

##### demo3：demo2太慢还可以优化

###### 问题分析

我们在看一下count++操作，count++操作实际上是被拆分为3步骤执行：

```java
1. 获取count的值，记做A：A=count
2. 将A的值+1，得到B：B = A+1
3. 让B赋值给count：count = B
```

方式2中我们通过加锁的方式让上面3步骤同时只能被一个线程操作，从而保证结果的正确性。

我们是否可以只在第3步加锁，减少加锁的范围，对第3步做以下处理：

```java
获取锁
第三步获取一下count最新的值，记做LV
判断LV是否等于A，如果相等，则将B的值赋给count，并返回true，否者返回false
释放锁
```

如果我们发现第3步返回的是false，我们就再次去获取count，将count赋值给A，对A+1赋值给B，然后再将A、B的值带入到上面的过程中执行，直到上面的结果返回true为止。



demo:

```java
package cn.itcast.cas;

import ch.qos.logback.classic.turbo.TurboFilter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName juc
 * @Package cn.itcast.cas
 * @ClassName CasTest1
 * @Author ZCC
 * @Date 2022/06/02
 * @Description java cas  模拟用户访问网站 统计网张毅用户访问总次数(使用synchronized优化)
 * @Version 1.0
 */
@Slf4j(topic = "c.CasTest1")
public class CasTest3 {
    static ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
    static ReentrantLock lock = new ReentrantLock();

    //访问次数
    volatile static  int requestCount = 0;
    //模拟访问一次

    public static void request() throws InterruptedException {
        //模拟耗时5毫秒


        TimeUnit.MILLISECONDS.sleep(5);
        //预期的值
        int expectCount;
        do {
            expectCount = getCount();

        } while (!compareAndSwap(expectCount, expectCount + 1));



    }

    /*
    获取当前访问次数
     */
    public static int getCount() {
        return requestCount;
    }

    /**
     * @throws
     * @title compareAndSwap
     * @description
     * @author zcc
     * @param: expectCount  期望count的值
     * @param: newCount     需要给count赋的新值
     * @date 2022/6/2 17:22
     * @return: boolean
     */
    public static synchronized boolean compareAndSwap(int expectCount, int newCount) {
        //判断count当前值是否和期望的expectCount一样，如果一样将newCount赋值给count
        if (getCount() == expectCount) {
            requestCount = newCount;
            return true;

        }
        return false;

    }

    public static void main(String[] args) throws InterruptedException {
        long starTime = System.currentTimeMillis();
        // 100个用户同时访问网站 每个用户访问十次
        int user = 100;
        CountDownLatch countDownLatch = new CountDownLatch(user);
        for (int i = 0; i < user; i++) {
            executorService.execute(() -> {
                //    模拟一个用户访问10次

                boolean falg = false;
                try {
                    for (int j = 0; j < 10; j++) {

                        request();
                        falg = true;
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {

                    if (falg) {

                        countDownLatch.countDown();
                    }
                }


            });


        }

        countDownLatch.await();
        executorService.shutdown();
        long endTime = System.currentTimeMillis();
        log.info(Thread.currentThread().getName() + "，耗时：" + (endTime - starTime) + ",count=" + requestCount);
    }
}

```

输出：

```java
17:43:52.792 c.CasTest1 [main] - main，耗时：463,count=1000
```

###### 总结

代码中用了`volatile`关键字修饰了count，可以保证count在多线程情况下的可见性。**关于volatile关键字的使用，也是非常非常重要的**。

咱们再看一下代码，`compareAndSwap`方法，我们给起个简称吧叫`CAS`，这个方法有什么作用呢？这个方法使用`synchronized`修饰了，能保证此方法是线程安全的，多线程情况下此方法是串行执行的。方法由两个参数，expectCount：表示期望的值，newCount：表示要给count设置的新值。方法内部通过`getCount()`获取count当前的值，然后与期望的值expectCount比较，如果期望的值和count当前的值一致，则将新值newCount赋值给count。

再看一下request()方法，方法中有个do-while循环，循环内部获取count当前值赋值给了expectCount，循环结束的条件是`compareAndSwap`返回true，也就是说如果compareAndSwap如果不成功，循环再次获取count的最新值，然后+1，再次调用compareAndSwap方法，直到`compareAndSwap`返回成功为止。

代码中相当于将count++拆分开了，只对最后一步加锁了，减少了锁的范围，此代码的性能是不是比方式2快不少，还能保证结果的正确性。大家是不是感觉这个`compareAndSwap`方法挺好的，这东西确实很好，java中已经给我们提供了CAS的操作，功能非常强大。





### 线程的生命周期



![image](2FBEA23FBF1D4AA8AEFD1D630AAEA051)